<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc maxdepth="2"?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:lang="nn">
<info>
<title>Programmering</title>
<date>2016-10-06</date>
<author>
<personname>
<firstname>halftan@online.no</firstname>
</personname>
</author>
<authorinitials>h</authorinitials>
</info>
<preface>
<title></title>
<blockquote>
<attribution>
Kristen Nygaard
</attribution>
<simpara>Å programmere er å forstå.</simpara>
</blockquote>
</preface>
<preface xml:id="_forord">
<title>Forord</title>
<simpara>Hensikten med denne boka er å prøve å forklare hvordan man kan lage et
dataprogram ved help av programmeringsspråket <emphasis>C</emphasis>.</simpara>
<simpara>Det å lage et dataprogram kan sammenlignes med å skrive en roman, eller
konstruere en større eventyrfortelling. Før man kan begynne, må man beherske et
skriftspråk. Eller i vårt tilfelle, et
programmeringsspråk. Her er det mange meninger omkring hvilket språk som er best,
og hvordan man i så fall skal gå frem for å lære seg dette. Etter at man har
lært seg et eller annet programmeringsspråk, er det enda flere meninger omkring hvordan
man bør gå frem for å konstruere selve programmet.</simpara>
<simpara>Jeg har valgt å fokusere på <emphasis>C</emphasis>, og på det aller mest grunnleggende
ved dette språket. Jeg tror det er viktig å ha en god forståelse om de
grunnleggende byggeklossene, når man skal lære seg noe nytt. Alt vi skal gå
gjennom i denne boka er av en slik karakter. Det kan kanskje virke litt kjedelig
i starten. Men, tro meg, når du har kontroll på de grunnleggende prinsippene, vil
du ha et mye bedre fundament for å skjønne resten. I denne sammenhengen er
<emphasis>C</emphasis>-programmering spesielt bra, siden de fleste andre programmeringspråk
 har sitt utspring eller tankegods, nettopp fra <emphasis>C</emphasis>. Derfor vil du lettere kunne
forstå et nytt programmeringsspråk, om du først kjenner litt til <emphasis>C</emphasis>.</simpara>
<simpara>Det som kanskje skiller rådene i denne boka, litt fra de som
allerede finnes, er at disse er skrevet på norsk, på en
muntlig form, og primært rettet mot skoleelever. Jeg tenker at en ungdom som
går på ungdomsskolen og som skjønner hvordan en enkel matematisk funksjon
fungere, kan lære litt om programmering ut fra det som står her.</simpara>
<simpara>Skjønner du dette, er det bare å kjøre på:</simpara>
<screen>En funksjonen er definert ved uttrykket f(x) = x + 1

Gitt at x = 2

Får vi at

f(x) = x + 1
f(2) = 2 + 1
f(2) = 3</screen>
<simpara>Dataprogrammet er <emphasis role="strong">x+1</emphasis>. Input til dataprogrammet er <emphasis role="strong">2</emphasis>. Og svaret fra
dataprogrammet er <emphasis role="strong">3</emphasis>.</simpara>
<simpara>Dette er programmering. Værre er det i bunn og grunn ikke. Alt en datamaskin
gjør er å automatisere denne prosessen, slik at den kan
gjentas et ufattelig antall ganger, med forskjellig innputt. Det å programmere
handler om å handtere kompleksitet. For å handtere kompleksitet må vi
forenkle og abstrahere, og for å kunne forenkle og abstrahere må vi kunne
modellere og analysere.</simpara>
<simpara>Denne boka prøver å gi en introduksjon til disse ulike
begrepene. Dette skal vi få til ved å relatere disse abstrakte utrykkene
til konkrete problemer som vi støter på i forbindelse med at vi utvikler to
dataprogram. Det første dataprogrammet vi skal lage, er et program som
hjelper oss å avvikle et skirenn. Det andre programmet vi skal lage er
et <emphasis>SpaceInvader</emphasis> -lignende spill.</simpara>
<simpara>Du må ikke lure deg selv til å tro at du
kan lære deg å programmere, uten at du jobber deg gjennom alle eksemplene som
vi skal se på. Programmering er på sett og vis også et handtverk, og et
handtverk må øves inn for å kunne mestre det. For de fleste
av oss finnes det ingen snarveier i så måte.</simpara>
<blockquote>
<attribution>
En hver voksen person
</attribution>
<simpara>Suksess skyldes
ikke talent, men
hardt arbeid og litt flaks.</simpara>
</blockquote>
<simpara>Årsaken til at du bør sette deg litt inn i hvordan man lager et dataprogram,
er fordi datamaskiner blir en stadig viktigere del av tilværelsen. Vi omgir oss
med dem nærmest hele tiden, og de utfører oppgaver
på vegne av oss stadig vekk. Ringer du med en mobiltelefon bruker du egentlig en
datamaskin. Kjører du en tur med en ny bil, bruker du flere hundre
datamaskiner. Ser du på TV eller bruker Internet, er flere tusen i sving for å
utføre oppgaver på vegne av deg. Derfor er det viktig at flest mulig har en
forståelse av hva en datamaskin er, og hvordan denne kan programmeres.</simpara>
<simpara>Denne boka prøver å gi deg litt innsikt i hvordan du kan
programere i programmeringsspråket <emphasis>C</emphasis>. Du trenger egentlig ingen annen bakgrunn
enn litt nysgjerrighet. Når du har jobbet deg gjennom boka, vil du sitte igjen
med en god forståelse av hva det innebærer å lage programvare. De verktøyene og
metodene som omtales, er for det meste grunnleggende teknologi som har vært med
oss i mange ti-år, men som fortsatt er <emphasis>state-of-the-art</emphasis>. Bare det, er et
argument for å lære seg enkel <emphasis>C</emphasis>-programmering  :-)</simpara>
</preface>
<glossary xml:id="_ordliste">
<title>Ordliste</title>
<simpara>Her er ei samling ord og uttrykk som vi i større eller mindre
grad, må kjenne til når vi skal uvikle programvare. Mange av disse
begrepene må modnes for å få en
forståelse av hva de egentlig betyr. Derfor velger jeg å definere disse i et eget
kapittel som heter <emphasis>ordliste</emphasis>. På den måten blir det litt lettere å komme tilbake
og se nærmere på et eller flere begrep, når du jobber deg gjennom boka.</simpara>
<glossentry>
<glossterm>Abstraksjon</glossterm>
<glossdef>
<simpara>På en måte kan vi si at alt som har med programmering å gjøre har med
det å abstrahere. <emphasis>Wikionary</emphasis> definerer det å abstrahere som det <emphasis>å trekke fram
visse vesentlige egenskaper ved noe, og se bort fra andre mer uvesentlige</emphasis>. Når man
abstrahere noe, kan man gjøre det av ulik grad, eller på ulike nivå. Når to
programmerere skal diskutere ei problemstilling, er det viktig at de er på
samme abstraksjonsnivå. Dette gjelder vel egentlig i alle livets aspekter, men når
vi lager programmvare må vi i alle fall være bevist på at vi forenkler
virkeligheten i den hensikt å kunne forstå og løse ei problemstilling. Og at vi
forenkler den i ulik grad, avhening av hvor vi er i prossessen.</simpara>
</glossdef>
</glossentry>
<glossentry>
<glossterm>Modell</glossterm>
<glossdef>
<simpara>Det å abstrahere er bokstavelig talt, et abstrakt begrep. I prosessen å bevege
seg fra en abstrakt tanke frem til ei konkret løsning, innfører vi begrepet; <emphasis>en modell</emphasis>.
<emphasis>Wikionary</emphasis> definerer en modell i denne sammenhengen, som en <emphasis>forenklet beskrivelse, figur
eller fysisk objekt laget for å forklare og fremheve hvordan noe fungerer</emphasis>. Jeg
skal prøve å konkretisere dette med et eksempel. Tenk deg en bil. Hvordan skal vi
beskrive denne? Hva består den av; hva er de viktigste bestanddelene? En måte å
gi svar på disse spørsmålene, er ved å lage en modell, for eksempel i form av ei
skisse. Vi kunne også laget denne modellen i form av ei liste, som
vi for eksempel kunne kalle for <emphasis>bil</emphasis>. Elementene i denne lista kunne for
eksempel være; fire dører, fire hjul, to støtfangere. Legg merke til at med en gang
vi lager en modell av noe, så forenkler vi virkeligheten. Vi gjør automatisk en
seleksjon i det vi velger oss ut noen atributter eller egenskaper, som vi tror
er viktigst. Men, vi har i alle fall begynt prosessen i det å konkretisere ei
løsning på ei problemstilling. Nedenfor ser vi to ulike modeller av en bil; ei tegning
og ei liste.</simpara>
</glossdef>
</glossentry>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="bilder/bil.jpg" contentwidth="200"/>
</imageobject>
<textobject><phrase>300</phrase></textobject>
</mediaobject>
</informalfigure>
<literallayout class="monospaced">bil: fire dører, fire hjul, to støtfangere</literallayout>
<variablelist>
<varlistentry>
<term>Programmeringsspråk</term>
<listitem>
<simpara>En vanlig datamaskin er bygd opp av mange milliarder transistorer. Disse er satt
sammen til ulike logiske kretser som kan programmeres ved hjelp av noe som heter
et maskinspråk eller maskinkode. Når vi skal lage vårt dataprogram, så skal vi
bruke et programmeringsspråk, som på en eller annen måte, ender opp til å bli slik
maskinkode. Hvordan dette skjer, er så pass komplekst, at vi velger å abstrahere
oss litt bort fra det. Vi sier bare at vi definerer dataprogrammet vårt i et
programmeringsspråk, som ender opp som maskinkode som igjen styrer de ulike
logiske enhetene i datamaskinen. Det er en rekke ulike programmeringsspråk å
velge mellom. Hvilke programmeringsspråk som er best, vil variere mellom hvem
du spør og hvilket problem du ønsker å løse.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Kompilator</term>
<listitem>
<simpara>Vi skal se på et programmeringsspråk som heter <emphasis>C</emphasis>. Det vil si at vi skal skrive
vanlig <emphasis>C</emphasis>-kode, som vanlig tekst, i en vanlig teksteditor, slik mange programmerere
har gjort det siden tidlig 1970-tall. Denne <emphasis>C</emphasis>-koden, som er vanlig tekst, skal vi
kompilere om til maskinkode som en datamaskin kan forstå og bruke. Det som er litt
bra med <emphasis>C</emphasis>-kode, er at slik kode kan omgjøres til nærmest en hvilken som helst
maskinkode på nærmest en hvilken som helst datamaskin. Det som er poenget her, er
at prosessen i å omgjøre ei vanlig tekstfil med kode, om til maskinkode, kalles å
kompilere. Og for å kompilere bruker vi en kompilator.   <emphasis>Wikionary</emphasis> definerer ordet
kompilator slik: <emphasis>et dataprogram som oversetter – kompilerer – et dataprogram skrevet
i et programmeringsspråk (kalt kildekode) til et kjørbart program (maskinkode).
Dette kan sammenlignes med å være tolk for to personer som snakker forskjellig språk;
tolken oversetter det den ene sier, slik at den andre personen klarer å dra
nytte av – dvs. forstå – informasjonen</emphasis>. Et viktig moment å få med seg her, er at
den samme kildekoden (altså vårt C-program) kan kompileres om til en rekke ulike
typer maskinkode for en rekke ulike typer datamaskiner, avhengig av hvilken kompilator
vi velger å bruke. Du vil kanskje ikke se det helt store med dette med en gang, men i
sin tid (en gang på 70-tallet) var faktisk dette ganske revolusjonerende.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Variabel</term>
<listitem>
<simpara>For en tid tilbake leste jeg et intervju med en kvinnelig systemutvikler, hvor hun
beskrev jobben sin som programmerer. Hun kom med en flott metafor på det å
programmere; hun såg for seg ei stor bokhylle med mange ulike ekser, hvor hver
slik eske innholdt data som programmet hennes oppdaterte eller flyttet rundt på.
Dette er egentlig et fantastik godt bilde på hva som egentlig skjer. Vi har somregel
en god del data, som vi strukturerer i ulik modeller, og alt programmet vårt gjør er
å manipulere på denne modellen. En modell består av mindre deler som vi kaller for
variabler.
<emphasis>Wikionary</emphasis> definerer ordet variabel slik; <emphasis>et symbol som representerer et
vilkårlig tall eller element i en mengde. Elementene i denne mengden kalles
verdiene til variabelen</emphasis>.
Ovenfor laget vi en modelle av en bil i form av ei liste, som vi kalte
for <emphasis>bil</emphasis>. Denne lista hadde flere elementer, blant annet elementet <emphasis>fire dører</emphasis>.
Dette kan vi representere ved hjelp av en variabel som vi kaller for <emphasis>dører</emphasis> og som
vi gir verdien <emphasis>4</emphasis>. Merk deg at tallet fire er del av en eller annen definert
mengde. Dette blir klarere etthvert når vi begynner å definere ulik typer variabler.</simpara>
</listitem>
</varlistentry>
</variablelist>
<literallayout class="monospaced">dører = 4</literallayout>
</glossary>
<chapter xml:id="_introduksjon">
<title>Introduksjon</title>
<simpara>Datamaskinen er etter hvert blitt en kompleks maskin bestående av flere
milliarder ulike komponenter. En av årsakene til dette er at det har vist seg relativt
enkelt å stadig lage mer rikholdige datamaskiner med hensyn til de
komponentene som inngår. Når det derimot kommer til hvordan vi programmerer
maskinene, har det ikke skjedd en tilsvarende rivende utvikling. Det har riktig nok
vært en utvikling på dette området også, men vi kan ikke si at den har
vært like stor.</simpara>
<section xml:id="_hvorfor_akkurat_emphasis_c_emphasis">
<title>Hvorfor akkurat <emphasis>C</emphasis></title>
<simpara>Siden 1970-tallet har programmeringsspråket <emphasis>C</emphasis> vært en av bærebjelkene når det
kommer til det å lage programvare. For eksempel er de mest sentrale delene i de
fleste operativsystemene (e.g. Windows, Linux, Mac OS X) laget
i C. Android som svært
mange har et, bokstavelig talt, nært forhold til, består også hovedsakelig av
<emphasis>C</emphasis>-kode. I tillegg benyttes hovedsakelig <emphasis>C</emphasis> når det kommer til <emphasis>embeddet systems</emphasis>,
det vil si alle de små datamaskinene som du finner i biler, motorsykler, traktorer, vaskemaskiner etc.</simpara>
<simpara>En årsak til at programmerignsspråket <emphasis>C</emphasis> er så mye anvendt, kan være at dette spåket
gir en tilsynelatende optimal abstraksjon inn mot sentrale komponenter i en
datamaskinen. <emphasis>C</emphasis> benyttes til å lage kode for alt fra små sykkel-computere til
store datasystem som beregner været, eller installasjoner som sendes ut i verdensrommet.</simpara>
<simpara>Derfor er det vel anvendt tid å lære seg å programere i <emphasis>C</emphasis>. <emphasis>C</emphasis> er også et enkelt
språk å lære seg og etter at du har lært deg litt <emphasis>C</emphasis>, vil det være mye lettere å
forstå tankegangen bak en rekke andre programmeringsspråk som finnes der ute.</simpara>
</section>
<section xml:id="_hva_er_en_datamaskin">
<title>Hva er en datamaskin</title>
<simpara>Som nevnt kan en datamaskin være alt fra den 8-bits datamaskinen som gjemmer seg
inne i sykkel-computeren din, til svære distribuerte datasystemer hvor de ulike
delene befinner seg på flere steder rundt om i verden.</simpara>
<simpara>Vi skal definere datamaskinen slik vi ser den som en <emphasis>C</emphasis> -programmerer som lager
et dataprogram for en datamaskin som har et operativsystem. Sagt på en annen måte; som en
C-programmerer som lager et program for Linux, Windows, Mac eller Android.</simpara>
<simpara>Den enkleste modellen vi da kan komme opp med, er et system som bastert på noe
input, utfører en beregning som presenteres på en eller annen output-enhet.</simpara>
<literallayout class="monospaced">input -&gt; compute -&gt; output</literallayout>
<simpara>En datamaskin kan ikke finne på noe helt av seg selv. Alt som presenteres, for
eksempel som tekst på en skjerm, er basert på at det er gjort en eller flere
beregninger på noe data som er gitt som input. Vi kan som nevnt derfor sammenligne
et dataprogram med en matematisk funksjon, som for eksempel denne:</simpara>
<literallayout class="monospaced">f(x) = x² + 2</literallayout>
<simpara>Her er x input, f(x) er output, og selve beregningen er x² + 2.</simpara>
<literallayout class="monospaced">input --&gt; compute --&gt; output
x --&gt; x² + 2 --&gt; f(x)
1 --&gt; 1² + 2 --&gt; 3</literallayout>
<simpara>En annen måte å se på det å programmere kan være å si at det å programmere er
å endre på data. Vi plasserer data i ulike beholdere, gjerne
kalt variabler, og programmet vi lager manipulerer på innholdet i disse
beholderne. Vi kan med andre ord se på variablen x ovenfor som en beholder
hvor vi plasserer tallet 1 og deretter utfører ei beregning basert på
formelen x^2+2 og får til slutt ut svaret 3, som vi igjen plasserer i beholderen
som vi kaller for f(x).</simpara>
<simpara>Gitt denne metaforen kan vi kanskje se på datamaskinen som ei stor bokhylle,
med mange ulike bokser eller esker, hvor vi kan plassere data.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="bilder/bokhylle.jpg" contentwidth="400"/>
</imageobject>
<textobject><phrase>600</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Tenk deg en boks hvor du kan lagre et heltall mellom 1 og 100. I denne boksen
legger du tallet 15. Deretter lager du et dataprogram som øker dette tallet
med 5. Hva blir da verdien på tallet i boksen?</simpara>
<literallayout class="monospaced">Boks b
b = 15
b = b + 5
Vis verdien til b på skjermen. (b er nå lik 20)</literallayout>
<simpara>Det som gjør det hele kompleks, er at det finnes mange ulike bokser og uendelig
mange muligheter når det kommer til hvordan vi kan endre innholdet i disse.</simpara>
<simpara>Skal du lage en enkel kalkulator som øker verdien til et tall med 5, så holder
det kanskje med en boks som kan lagre heltall mellom 1 og 100. Men skal du for
eksempel, lage en teksteditor må du ha en boks som kan lagre tekst. Det finnes
mange ulike behov som gjør at vi lager oss mange ulike boksen eller variabler.
Men, prinsippet er det samme; vi oppretter noe data i en eller flere variabler,
for deretter å endre på innholdet i disse ved hjelp av et dataprogram.</simpara>
<simpara>Det at vi bruker begrepet boks eller variabel, på den beholderen som lagrer den
informasjonen vi ønsker å endre på, kaller vi for en abstraksjon. Egentlig ligger
informasjonen i ulike registre inne i datamaskinen, som igjen er bygd opp av
transistorer, som vi denne sammenhengen kan se på som små brytere som enten er
på eller av; 1 eller 0. Igjen har vi det at egentlig så er ikke dette så
vanskelig å forstå. Men, størrelseorden med hensyn til antallet slike brytere,
og kompleksiteten med hensyn til hvordan de er satt sammen, er av en slik art
at det neppe finnes en enkeltperson som har den fulle og hele oversikten.</simpara>
<simpara>En datamaskin er en kompleks sammenstilling av mange små komponenter, og vi
konstruere oss ulike abstraksjoner og forenklinger for å klare å forstå hva som skjer.</simpara>
<simpara>Og som nevnt, en årsak til at C er et populært programmeringsspråk, kan være at
nettopp dette språket har en tilsynelatende optimal abstraksjon inn mot selve
datamaskinen. På mange måter kan vi si at beviset på dette ligger i muligheten
til å lage et dataprogram i C,  som du kan få til å kjøre på mange ulike
datamaskiner. C er også et kjekt programmeringsspråk å lære seg når man ønsker å
lære mest mulig rundt hvordan en datamaskin egentlig fungerer. Sagt på en annen måte;
C har et lavere abstrasjonsnivå inn mot selve datamaskinen, enn en rekke andre språk. Dette
er bra i noen sammenhenger, og ikke fullt så bra i andre. I vår sammenheng, hvor
vi skal lære grunnleggende ferdigheter rundt det å programmere en datamaskin, mener jeg
dette er bra.</simpara>
</section>
</chapter>
<chapter xml:id="_kom_i_gang">
<title>Kom i gang</title>
<simpara>Nå er det på tide å begynne med praktisk arbeid. Som nevnt; det å
programmere er på sett og vis et handtverk, og kan langt på vei kun læres
ved praktisk arbeid. Derfor må vi aller først installere en teksteditor som
gjør det mulig å skrive <emphasis>C</emphasis>-kode. Deretter skal vi installere en kompilator, som
kan omgjøre <emphasis>C</emphasis>-koden til et kjørbart dataprogram. Når det er gjort, skal vi
kode det obligatoriske <emphasis>"Hello World"</emphasis>-eksempelet, som skriver ut teksten;
<emphasis>"Hello world"</emphasis> på skjermen.</simpara>
<formalpara>
<title>Læringsmål</title>
<para>
<screen> - installere en egnet teksteditor
 - installere en egnet kompilator
 - kode, kompilere og kjøre det obligatoriske "Hello World" -eksempelet</screen>
</para>
</formalpara>
<simpara>For å ta det siste først, så er det slik at alle lærebøker i <emphasis>C</emphasis> må
starte med et eksempel som skriver ut teksten "Hello World" på skjermen. Slik er
det bare. Den historiske forklaringa til dette er at den opprinnelig
læreboka i C gjør nettop det.</simpara>
<simpara>Så, derfor, her er det:</simpara>
<formalpara>
<title>test.c (eksempel 1)</title>
<para>
<programlisting language="c" linenumbering="unnumbered">#include &lt;stdio.h&gt; <co xml:id="CO1-1"/>

int main (int argc, char *argv[]) { <co xml:id="CO1-2"/>

    printf("Hello world!\n"); <co xml:id="CO1-3"/>

    return 0; <co xml:id="CO1-4"/>

}</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO1-1">
<para>Inkluderer litt kode som blant annet definerer funksjonen printf().</para>
</callout>
<callout arearefs="CO1-2">
<para>Her starter vårt program, i.e. main-funksjonen.</para>
</callout>
<callout arearefs="CO1-3">
<para>Her skriver vi 'Hello World!' ut på skjermen vha funksjonen printf().</para>
</callout>
<callout arearefs="CO1-4">
<para>Her returnerer vi verdien null til operativsystemet, som startet vårt program.</para>
</callout>
</calloutlist>
<simpara>Vi skal ganske snart gå gjennom dette eksempelet i detalj, men før vi kommer så
langt, skal vi <emphasis>sette opp et uviklingsmiljø</emphasis>. Vårt utviklingsmiljø vil primært
bestå av to programmer; en teksteditor og en kompilator. I utgangspunktet
er det nesten det samme hvilken teksteditor og <emphasis>C</emphasis>-kompilator du velger
å bruke. Alle eksemplene vi går gjennom, skal være forsøkt
laget slik at de skal kunne fungere på en rekke ulike datamaskiner; Windows,
Linux, Mac etc. Jeg velger likevel å fokusere på Windows, siden jeg antar at de
fleste bruker en slik datamaskin.</simpara>
<simpara>Når det gjelder Windows, er det er en mange ulike alternativer å velge mellom,
både når det gjelder valg av teksteditor og valg av kompilator. Jeg velger å bruke Cygwin.
Cygwin er en rekke små program som gjør det mulig å simulere et Linux-miljø.
Deriblant også et utviklingsmiljø for <emphasis>C</emphasis>, i form at en
kompilator kalt <emphasis>gcc</emphasis>. Utover selve kompilatoren innholder Cygwin også et
skall eller terminalvindu, hvor vi kan kjøre <emphasis>gcc</emphasis>-programmet.</simpara>
<section xml:id="_slik_installerer_du_cygwin_gcc">
<title>Slik installerer du Cygwin gcc</title>
<simpara>Installering av Cygwin fungerer slik, at du starter et program som heter <emphasis>setup-x86.exe</emphasis>
<footnote><simpara>Du kan velge mellom 32 eller 64 bit&#8217;s installasjon. Jeg velger 32 :-)</simpara></footnote>.
Ved hjelp av dette programmet velger du hvilke programpakker du ønsker å
installere. Hovedbildet til Cygwin, hvor du velger de ulike pakkene, er vist nedenfor.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="bilder/cygwin.png" contentwidth="400"/>
</imageobject>
<textobject><phrase>600</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Skriv gcc i søkefeltet, som vist. Sjekk om pakken <emphasis>gcc-core</emphasis> er valgt, under <emphasis>Devel</emphasis>.
Gcc er en fundamental del i et hvert Linux-lignende system, derfor vil
gcc-core ganske sikkert allerede være valgt. Men, om så ikke skulle være tilfelle, velger
du denne, og trykker på neste-knappen helt til <emphasis>setup wizarden</emphasis> er ferdig.</simpara>
<simpara>Om alle gode krefter er med oss, skal vi ende opp med noe slikt som dette:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="bilder/cygwin2.png" contentwidth="600"/>
</imageobject>
<textobject><phrase>900</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Her har jeg åpnet et cygwin terminalvindu, og skrevet inn kommandoen; <emphasis role="strong">gcc</emphasis>.
Gcc er verdt en liten studie i seg selv, for å si det forsiktig. Bokstavene gcc
er et akronym for "gnu c compiler" <footnote><simpara>The abbreviation GCC has multiple meanings in common use.  The current official meaning is “GNU Compiler Collection”, which refers generically to the complete suite of tools. The name historically stood for “GNU C Compiler”, and this usage is still common when the emphasis is on compiling C programs.  Finally,  the name is also used when speaking of the language-independent component of GCC: code shared among the compilers for all supported languages. For mer informasjon, se gcc.gnu.org</simpara></footnote>, hvor gnu igjen er et såkalt rekursivt akronym for <emphasis>GNU is Not Unix</emphasis>.</simpara>
<simpara>For å kompilere et <emphasis>C</emphasis>-programm ved hjelp av gcc, skriver du i utgangspunktet bare gcc,
samt navnet på den tekstfila som inneholder din <emphasis>C</emphasis>-kode, slik:</simpara>
<literallayout class="monospaced">gcc test.c</literallayout>
<simpara>gcc vil da produsere ei fil som heter <emphasis>a.exe</emphasis>.
Dette programmet kan du starte ved å skrive:</simpara>
<literallayout class="monospaced">./a.exe</literallayout>
<simpara>Vi kommer snart tilbake til dette når vi skal skrive vårt obligatoriske <emphasis>Hello World</emphasis> -program.
Men, før vi får skrevet vårt første <emphasis>C</emphasis>-program, må vi installere en god teksteditor. Vi kunne brukt Windows Notepad,
men går heller for en litt mer pimpa editor, kalt <emphasis>Notepad++</emphasis>. (Uttales Notepad-pluss-pluss.)</simpara>
</section>
<section xml:id="_slik_installerer_du_notepad">
<title>Slik installerer du Notepad++</title>
<simpara>Notepad-pluss-pluss har etterhvert utviklet seg til å bli kanskje den beste generelle teksteditoren
som er å oppdrive for Windows? I tillegg er den, som kompilatoren gcc, helt gratis å laste ned og bruke.
Du finner <emphasis>Notepad-pluss-pluss</emphasis> her:</simpara>
<literallayout class="monospaced">https://notepad-plus-plus.org/</literallayout>
<simpara>Om alle gode krefter fortsatt er med oss, skal vi ende opp med noe som ligner dette her:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="bilder/notepadpp1.png" contentwidth="600"/>
</imageobject>
<textobject><phrase>900</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Som du ser, jeg har jeg tastet inn "Hello World" -eksempelet som vi kjenner
litt fra før.</simpara>
<simpara>Jeg lagrer denne teksten i ei fil, som jeg kaller for <emphasis>test.c</emphasis></simpara>
<simpara>Fila plasserer jeg her:</simpara>
<literallayout class="monospaced">c:\cygwin\home\halftan\src\cprg\cprogramming\eksempel1\</literallayout>
<simpara>Legg merke til at hjemmekatalogen min, på mitt Cygwin-system, er:</simpara>
<literallayout class="monospaced">c:\cygwin\home\halftan\</literallayout>
<simpara>Du kan godt lagre din <emphasis>test.c</emphasis> -fil rett på din hjemmekatalog. Deretter åpnet du et
cygwin-terminalvindu og skriver inn kommandoen som kompilerer tekstfila <emphasis>test.c</emphasis>, og gjør den
om til ei kjørbar binærfil, kalt <emphasis>a.exe</emphasis> Tilslutt skriver du <emphasis>./a.exe</emphasis> for å kjøre programmet som du
nettopp har laget.</simpara>
<simpara>Om vi ha litt flaks, skal du se at teksten <emphasis>"Hello World"</emphasis>, dukker opp i terminalvinduet, og vips; du har laget ditt første dataprogram!</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="bilder/cygwin3.png" contentwidth="600"/>
</imageobject>
<textobject><phrase>900</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Alle eksemplene som vi skal gå gjennom, eksisterer allerede som tekstfiler. Disse finner du her:</simpara>
<literallayout class="monospaced">https://github.com/halftanolger/cprogrammering</literallayout>
<simpara>Git og github er også verdt et lite studium i seg selv. Her bruker jeg github
som en lagringsplass for dette bokprosjektet, deriblant all eksempelkoden. Om du
ønsker <emphasis>å sjekke ut</emphasis> alle eksemplene fra denne lagringsplassen, kan du
gjøre det slik:</simpara>
<literallayout class="monospaced">mkdir src <co xml:id="CO2-1"/>
cd src <co xml:id="CO2-2"/>
git clone https://github.com/halftanolger/cprogrammering <co xml:id="CO2-3"/></literallayout>
<calloutlist>
<callout arearefs="CO2-1">
<para>Opprett en katalog som heter src</para>
</callout>
<callout arearefs="CO2-2">
<para>Gå ned i denne katalogen</para>
</callout>
<callout arearefs="CO2-3">
<para>Hent <emphasis>cprogrammering</emphasis> fra github</para>
</callout>
</calloutlist>
<simpara>Prøv deretter å utfør:</simpara>
<literallayout class="monospaced">cd cprogrammering
cd eksempel1
cat test.c</literallayout>
<simpara>Da skal du forhåpentligvis se dette i terminalviduet ditt:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="bilder/cygwin4.png" contentwidth="600"/>
</imageobject>
<textobject><phrase>900</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>På samme måte som i sted, kan du nå skrive <emphasis>gcc test.c</emphasis> for å kompilere <emphasis>C</emphasis>-koden om til et
kjørpart dataprogram, som skriver ut teksten <emphasis>"Hello world"</emphasis> på skjermen.</simpara>
<simpara>Da er vi i gang! Vi har installert og fått prøvd, alle verktøyene vi trenger for å
programmere i C. Nå er det bare å begynne å bruke språket.</simpara>
</section>
</chapter>
<chapter xml:id="_innputt_utputt">
<title>Innputt &amp; Utputt</title>
<simpara>Som nevnt i starten; all databehandling dreier seg rundt det faktum at du sender
noe data inn i en prossess. Denne prosessen utfører deretter en eller flere beregninger.
Og tilslutt returnerer prosessen et svar tilbake. Derfor
er det viktig å forstå hvordan man så enkelt som mulig, kan gjøre dette ved hjelp
av <emphasis>C</emphasis>-kode. Det er læringsmålet med dette kapitlet.</simpara>
<formalpara>
<title>Læringsmål</title>
<para>
<screen> - innputt (aka input)
 - beregning
 - utputt (aka output)</screen>
</para>
</formalpara>
<simpara>Inn-putt og ut-putt er i forhold til operativsystemet<footnote><simpara>Windows og Linux er eksempler på operativsystem, det vil si det systemet som sørger for at datamaskinen vår fungerer; skjerm, mus, tastatur etc. Det er operativsystemet som starter de ulike programmene som kjører på datamaskinen.</simpara></footnote>. Det vil si at det
er operativsystemet, som når det starter programmet vårt, sender inn inn-putten. Det er det
samme operativsystemet som mottar ut-putten fra vårt program, når vårt program avsluttes.</simpara>
<simpara>Dette er innputt og utputt i sin enkleste form. Utover dette kan vi også si at vi har innputt
i form av data fra mus og tastatur, og utputt i form av informasjon på skjermen etc. Alt dette
kommer vi tilbake til. Aller først skal vi studere den aller enkleste formen for
innputt og utputt.</simpara>
<formalpara>
<title>test.c (eksempel 2)</title>
<para>
<programlisting language="c" linenumbering="unnumbered">int main () { <co xml:id="CO3-1"/>

    return 0; <co xml:id="CO3-2"/>

}</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO3-1">
<para>Innputt</para>
</callout>
<callout arearefs="CO3-2">
<para>Utputt</para>
</callout>
</calloutlist>
<simpara>Lagre denne koden i ei fil kalt; <emphasis>test.c</emphasis> og skriv:</simpara>
<literallayout class="monospaced">gcc test.c</literallayout>
<simpara>Kjør deretter programmet som ble produsert. Nå skal du ikke se noe på skjermen.
Men, det betyr ikke at programmet ikke returnerer noe tilbake til det
programmet som startet det.</simpara>
<simpara>Ok, så hva skjer egentlig her? Jo, dette er det enkleste C -programmet som er
mulig å skrive, og alt programmet gjør er å returnere tallet null tilbake til den
prosessen som startet programmet. Likevel er det mye å lære av det som skjer her.
Først merker vi oss at det er en eller annen prosess som starter det programmet vi lager.
Denne prosessen kjører gjerne i et eller annet operativsystem. Det er det samme
om vi snakker om Linux, Mac eller Windows; et annet program starter vårt program.</simpara>
<simpara>Tenk tilbake på dette:</simpara>
<literallayout class="monospaced">innputt → beregninger → utputt</literallayout>
<simpara>Det betyr at når du starter progammet, skal du kunne gi noe <emphasis>“innputt”</emphasis> til
programmet, som deretter skal <emphasis>“gjøre et eller annet”</emphasis> for til slutt å gi
tilbake noe <emphasis>“utputt”</emphasis>.</simpara>
<simpara>Vi venter litt med <emphasis>“innput”</emphasis> -delen og ser nærmere på <emphasis>“gjøre et eller annet”</emphasis> -delen
og <emphasis>“utputt”</emphasis> -delen.</simpara>
<simpara>I vårt tilfelle ovenfor, er <emphasis>“gjøre et eller annet”</emphasis> -delen å returnere tallet
null. Men, hvordan får vi tak i resultat?</simpara>
<simpara>Da må vi gå til det programmet som starter programet vårt. Og det programmet er
Cygwin terminal-programmet. Det er jo i dette programmet vi skriver:</simpara>
<literallayout class="monospaced">./a.out</literallayout>
<simpara>for å kjøre <emphasis>C</emphasis>-programmet vårt.</simpara>
<simpara>Det vil varierer litt hvordan man får tak i retur -verdien fra et program. I vårt
tilfelle hvor vi bruker Cygwin, kan du få tak i returverdien ved å skrive:</simpara>
<literallayout class="monospaced">echo $?</literallayout>
<simpara>For å oppsummere:</simpara>
<literallayout class="monospaced">gcc test.c
./a.out
echo $?
0</literallayout>
<simpara>Det vi har gjennomført ovenfor, er å kode, kompilere, kjøre samt sjekke
resultatet fra det enkleste <emphasis>C</emphasis>-programmet som er mulig å lage. Alt programmet
gjør er å returnere tallet null. Vi bruker
kommandoen <emphasis>echo $?</emphasis> for å vise det tallet som ble returnert til
skallet <footnote><simpara>Et terminalvindu kan også omtales som et skall, siden det engelse ordet <emphasis>shell</emphasis> er mest vanlig å bruke på slike typer dataprogram. linuxcommand.org : What is "the shell"? <emphasis>Simply put, the shell is a program that takes your commands from the keyboard and gives them to the operating system to perform. In the old days, it was the only user interface available on a Unix computer. Nowadays, we have graphical user interfaces (GUIs) in addition to command line interfaces (CLIs) such as the shell.</emphasis></simpara></footnote>.</simpara>
<simpara>Prøv nå å endre test-programmet til å returnere tallet 5</simpara>
<formalpara>
<title>test.c (eksempel 3)</title>
<para>
<programlisting language="c" linenumbering="unnumbered">int main() {

	return 5;

}</programlisting>
</para>
</formalpara>
<simpara>Lagre koden og skriv</simpara>
<literallayout class="monospaced">gcc test.c</literallayout>
<simpara>for deretter å kjøre programmet.</simpara>
<simpara>Skriv kommandoen:</simpara>
<literallayout class="monospaced">echo $?</literallayout>
<simpara>for å se returverdien fra programmet.</simpara>
<simpara>Som nevnt, alle C -program starter ved at en annet program
kaller opp funksjonen <emphasis>"main"</emphasis>.  Denne funksjonen returnerer et heltall.
Dette er definert ved at det står <emphasis>"int"</emphasis> forann  <emphasis>"main"</emphasis>. Det er også mulig å sende
informasjon inn til <emphasis>"main"</emphasis>. Det skal vi se på etter hvert. Men, først skal vi
dvele litt med med begrepet <emphasis>"funksjon"</emphasis>.</simpara>
<simpara>Vi kjenner til begrepet funksjon fra matematikken. Der ser gjerne en funksjon slik ut:</simpara>
<literallayout class="monospaced"> f(x) = x +1

 Sett inn x = 2

 f(2) = 2 + 1
 f(2) = 3

 input → beregninger → output
 2 → 2 +1 → 3</literallayout>
<section xml:id="_variabler">
<title>Variabler</title>
<simpara>Tidligere pratet jeg i bokser og variabler. Jeg sa at et dataprogram kan sees på
som instruksjoner som endrer på innholdet i ulike bokser med data.</simpara>
<simpara><emphasis>"int"</emphasis> er en slik boks med data som kan inneholde et heltall.  En måte å se
på dette, kan være som følger: terminalprogrammet har en boks hvor returverdien
kan lagres. Når terminalprogrammet kjører programet vårt, blir returverdien
lagt i denne boksen. Dermed kan terminalprogrammet etterpå vise verdien på skjermen.</simpara>
<simpara>Programmet vårt kan sees på som en funksjon som hele tiden returnerer tallet 5,
helt uavhengig av hva som sendes inn som intput.</simpara>
<literallayout class="monospaced"> f(x) = 5

 f(1) = 5
 f(2) = 5
 f(3) = 5</literallayout>
<simpara>La oss modifisere programmet slik at det legger sammen to tall.</simpara>
<formalpara>
<title>test.c (eksempel 4)</title>
<para>
<programlisting language="c" linenumbering="unnumbered">int main() {

	int a = 2;
	int b = 3;
	int c = a + b;

	return c;

}</programlisting>
</para>
</formalpara>
<simpara>Jeg oppretter tre bokser av typen <emphasis>int</emphasis>. (int &#8594; integer = heltall).
Legger 3 i den første, 4 i den andre, og summen av den første og den andre, i
den tredje. Til slutt returnerer jeg med det tallet som måtte ligge i den
tredje boksen.</simpara>
<simpara>Legg merke til at vi kan kalle databoksene for hva vi vil. Jeg har valgt å kalle dem a,b og c.</simpara>
<simpara>Skriv inn koden, og test ut.</simpara>
<simpara>Neste steg for oss blir å modifisere programmet vårt slik at det kan ta i mot
input fra skallet (eller input fra terminal-programmet om du vil).</simpara>
<simpara>Legg merke til at når du skal kompilere C-koden som ligger i fila <emphasis>test.c</emphasis>, så
oppgir du dette som input til programmet <emphasis>gcc</emphasis>, på denne måten:</simpara>
<literallayout class="monospaced">gcc test.c</literallayout>
<simpara>Det betyr at det du ønsker å putte inn som input til et C -program, skriver du i
tur og orden etter navnet på selve programmet. I vårt tilfelle,
om vi ønsker å gi noe input til programmet vårt, skriver vi noe slikt som dette:</simpara>
<literallayout class="monospaced">a.exe 2</literallayout>
<simpara>Da vil vi starte programmet med tallet 2 som input. Men, hvordan får vi tak
i dette tallet inne i programmet?</simpara>
<simpara>Modifiser <emphasis>test.c</emphasis> til å se slik ut:</simpara>
<formalpara>
<title>test.c (eksempel 5)</title>
<para>
<programlisting language="c" linenumbering="unnumbered">int main ( int argument_antall, char *argument_vektor[] ) {

	int x = atoi(argument_vektor[1]);

	return x + 1;

}</programlisting>
</para>
</formalpara>
<simpara>kompiler og test ved å utføre disse kommandoene:</simpara>
<literallayout class="monospaced"> &gt;gcc test.c
 &gt;a.exe 1
 &gt;echo $?
 &gt;2

 &gt;a.exe 2
 &gt;echo $?
 &gt;3

 &gt;a.exe 3
 &gt;echo $?
 &gt;4</literallayout>
<simpara>Jepp, her skjer det ting. Nå klarer vi å gi input til programmet vårt, vi utfører
ei enkel beregning ved å addere tallet 1 til det tallet som kommer inn, og vi
returnerer med svaret. Men, det som en gang var verdens minste C -program, har nå
blitt litt mer komplisert. Vi starter med:</simpara>
<literallayout class="monospaced">int argument_antall
char * argument_vektor[]</literallayout>
<simpara>Dette er to bokser eller to variabler. Den første er av typen <emphasis>int</emphasis>.
Det betyr at i variabelen som heter <emphasis>argument_antall</emphasis>, ligger det
et heltall. Dette heltallet angir antall argumenter inn til programmet. Egentlig
angir dette tallet antall argumenter, pluss 1, siden navnet til programmet også
regnes med når antallet input-argumenter telles opp. Det betyr i praksis at når
du skriver:</simpara>
<literallayout class="monospaced">a.exe 3</literallayout>
<simpara>så vil innholdet i <emphasis>antall_argument</emphasis> være lik 2, siden det første argumentet
er <emphasis>a.exe</emphasis> og det andre er <emphasis>3</emphasis>.</simpara>
<simpara>Altså, ved hjelp av variabelen <emphasis>argument_antall</emphasis> vet vi hvor mange argumenter som
kommer inn til programmet. For å få tak i selve argumentene må vi se nærmere
på variabelen som heter <emphasis>argument_vektor</emphasis>. Denne inneholder en
tabell med pekere av typen <emphasis>char</emphasis>, som peker mot en tekst-representasjon av de
ulike argumentene.</simpara>
<simpara>Ok, her kom det en rekke nye begrep på banen. Vi starter med typen <emphasis>char</emphasis>. Vi vet
fra før av at vi kan ha en variabel av typen <emphasis>int</emphasis>. Det betyr at innholdet i variabelen
kan være et heltall. Variabler av typen <emphasis>char</emphasis> er forsåvidt også heltall, men historisk
sett var disse heltallene tenkt å representere bokstaver.</simpara>
<simpara>Det betyr at, ønsker du deg en variabel som skal kunne lagre en bokstav, for
eksempel en <emphasis>a</emphasis>, så skriver du det slik:</simpara>
<programlisting language="c" linenumbering="unnumbered">char min_boks = ‘a’</programlisting>
<simpara>Her blir det opprette en variabel som heter <emphasis>min_boks</emphasis>. Denne variabelen er av
typen <emphasis>char</emphasis> og den tilordnes verdien, <emphasis>a</emphasis>.</simpara>
<simpara>Om verdien er et tegn, må dette stå med apostrof, som vist ovenfor.</simpara>
</section>
<section xml:id="_tabell_aka_array">
<title>Tabell (aka array)</title>
<simpara>Det er mulig å sette sammen slike enkeltbokstaver til ord og setninger. En slik
sammenstilling kaller vi for <emphasis>en streng</emphasis>. En streng lager vi ved å opprett en
tabell av <emphasis>char’s</emphasis>. For å angi at vi ønsker en tabell av <emphasis>char’s</emphasis> skriver vi
tegnene [] bak variabelnavnet, slik:</simpara>
<programlisting language="c" linenumbering="unnumbered">char min_streng[] = “Hei”;</programlisting>
<simpara>Strengen angis med anførselstegn.</simpara>
<simpara>Hvert enkelt tegn i strengen har sin plass i tabellen av <emphasis>char’s</emphasis>, noe som vi
kan vise med en slik figur:</simpara>
<literallayout class="monospaced">                      0   1   2   3
                    +---+---+---+---+
char min_streng[] = | H | e | i | 0 |
                    +---+---+---+---+</literallayout>
<simpara>Helt til slutt i en streng, plasserer C et null-tall for å markere hvor strengen slutter.</simpara>
<simpara>Om vi, bare som en øvelse, skulle ønske å lagre hver bokstav i tabellen, i sin
egen variabel, kan vi gjøre det slik:</simpara>
<programlisting language="c" linenumbering="unnumbered">char min_bokstav_h = min_streng[0]
char min_bokstav_e = min_streng[1]
char min_bokstav_i = min_streng[2]</programlisting>
<simpara>Vi ser at det er mulig å hente ut hvert enkelt tegn i tabellen, ved å angi
indeksen (eller plasseringa) til den aktuelle bokstaven i tabellen.</simpara>
<note>
<title>En streng er en tabell av tegn.</title>
<simpara>For å lagre en tekststreng (ord eller setninger) i <emphasis>C</emphasis>,
      bruker vi en databoks som består av ei samling av databoksen <emphasis>char</emphasis>. Ei slik
      samling kaller vi for en tabell. Vi bruker tegnene ‘[‘ og  ‘]’ bak
      variabelnavnet, for å angi at dette er en tabell av variabler.</simpara>
</note>
<simpara>Tre variabler som hver representerer ett tegn (char):</simpara>
<programlisting language="c" linenumbering="unnumbered">char a = ‘h’
char b = ‘e’
char c = ‘i’</programlisting>
<simpara>Tre variabler, som hver representerer ei samling tegn, altså en array av tegn (char’s):</simpara>
<programlisting language="c" linenumbering="unnumbered">char a[] = “Hei verden”
char b[] = “Hello world”
char c[] = “Bonjour monde”</programlisting>
<simpara>Ok, nå er vi kommet et stykke på vei til å forstå setningen:</simpara>
<simpara><emphasis>&#8230;&#8203; For å gå tak i selve argumentene må vi se nærmere på variabelen som heter
argument_vektor. Denne inneholder en tabell med pekere av typen ‘char’, som peker mot en tekst-representasjon av de ulike argumentene. &#8230;&#8203;</emphasis></simpara>
<simpara>Vi skjønner det med <emphasis>tekst-representasjon</emphasis>. Det vil si at vi klarer å lage en variabel
som inneholder en tekst. Det gjør vi ved å lage en tabell av <emphasis>char</emphasis> -variabler, slik:</simpara>
<literallayout class="monospaced">             0   1   2   3   4   5   6   7   8   9   10
           +---+---+---+---+---+---+---+---+---+---+---+
char a[] = | H | e | i |   | v | e | r | d | e | n | 0 |
           +---+---+---+---+---+---+---+---+---+---+---+</literallayout>
<literallayout class="monospaced">             0   1   2   3   4   5   6   7   8   9   10  11
           +---+---+---+---+---+---+---+---+---+---+---+---+
char b[] = | H | e | l | l | o |   | w | o | r | l | d | 0 |
           +---+---+---+---+---+---+---+---+---+---+---+---+</literallayout>
<literallayout class="monospaced">             0   1   2   3   4   5   6   7   8   9   10  11  12  13
           +---+---+---+---+---+---+---+---+---+---+---+---+---+---+
char c[] = | B | o | n | j | o | u | r |   | m | o | n | d | e | 0 |
           +---+---+---+---+---+---+---+---+---+---+---+---+---+---+</literallayout>
<simpara>Men, vi skal ha en tabell av pekere, som peker mot data av typen char.</simpara>
<simpara>Nå drar det seg litt til her.</simpara>
</section>
<section xml:id="_pekere">
<title>Pekere</title>
<simpara>For å forstå hva en peker er, må vi gå litt nærmere inn på hvordan en datamaskin
egentlig fungerer. Du har sikkert hørt om RAM (random access memory), eller bare kort og godt; <emphasis>minne</emphasis>.
En datamaskin har en viss mengde fysisk RAM, og mange tenker kun på minne når de
skal angi hvor stor en datamaskin er. De variablene vi har pratet om ovenfor,
ligger i minnet til datamaskinen. Dette minnet kan vi se på som en tabell av
databokser, hvor hver slik boks har sin egen adresse, på samme måte som hver
bokstav i en streng har sin egen index.</simpara>
<literallayout class="monospaced">+-----+-----+
| 001 |  H  |
+-----+-----+
| 002 |  e  |
+-----+-----+
| 003 |  i  |
+-----+-----+
| 004 |  0  |
+-----+-----+</literallayout>
<simpara>Dermed kan vi se på strengen vår på to måter. Både hvordan den er lagret i variabelen
i programmet vårt, og hvordan den egentlig er lagret i minnet.</simpara>
<programlisting language="c" linenumbering="unnumbered">char a[] = “Hei”</programlisting>
<literallayout class="monospaced">             0   1   2   3
           +---+---+---+---+
char a[] = | H | e | i | 0 |
           +---+---+---+---+</literallayout>
<literallayout class="monospaced">+---------------------+-----+
| 9223372036854775800 |  H  |
+---------------------+-----+
| 9223372036854775808 |  e  |
+---------------------+-----+
| 9223372036854775816 |  i  |
+---------------------+-----+
| 9223372036854775825 |  0  |
+---------------------+-----+</literallayout>
<simpara>Som nevnt, putter <emphasis>C</emphasis> på en null for å markere slutten på en streng. Derfor viser
jeg denne nullen alle plasser hvor det er relevant.</simpara>
<simpara>Ovenfor har jeg brukt noen store tall for å vise de ulike minne -addressene. Om du har
en 64 bits datamaskin, som for tiden er det normale, kan datamaskinen din nå 2^64 slike
minne -adresser. Dette er et stort tall, og viser litt hvor kraftig en datamaskin
egentlig er.</simpara>
<literallayout class="monospaced">Antall mennesker på jorden         7 000 000 000
Antall menneskehårstrå       700 000 000 000 000
2^64 er lik           18 446 744 073 709 551 615</literallayout>
<simpara>Når man programmerer i <emphasis>C</emphasis>, kan man nå innholdet til de ulike adressene ved å bruke en
konstruksjon som heter <emphasis>peker</emphasis>.</simpara>
<simpara>Om jeg ønsker meg en slik peker, som peker på strengen “Hei” ovenfor, kan jeg skrive</simpara>
<programlisting language="c" linenumbering="unnumbered"> char *min_peker = &amp;a</programlisting>
<simpara>Verdien som nå ligger i <emphasis>min_peker</emphasis> vil være 9223372036854775800, altså minneadressen
til den første bokstaven i strengen “Hei”.</simpara>
<simpara>Strengen “Hei” starter med adressen til den første bokstaven, og
varer helt til det dukker opp et null-tall.</simpara>
<simpara>Ampersand forann en variabel, betyr med andre ord; gi meg minneadressen til denne variabelen.</simpara>
<note>
<title>Databokser av ulik type</title>
<simpara>Når vi programmerer kan vi se på variablene som bokser, som kan inneholde
      ulike typer data. Hver type boks kan lagre sin type data. Og hver slik
      boks har sin unike adresse. Denne adressen kan man hente ut ved å sette en
      ampersand forann navnet til boksen.</simpara>
</note>
<programlisting language="c" linenumbering="unnumbered"> char a = ‘h’</programlisting>
<simpara>Disse boksene ligger i minnet til datamaskinen. Enhver minneplassering har sin adresse.</simpara>
<literallayout class="monospaced">+---------------------+-----+
| …                   |     |
+---------------------+-----+
| 9223372036854775800 |     |
+---------------------+-----+
| 9223372036854775808 |  h  |
+---------------------+-----+
| 9223372036854775816 |     |
+---------------------+-----+
| …                   |     |
+---------------------+-----+</literallayout>
<simpara>Om vi ønsker å få tak i denne adressen, skriver vi en ampersand ‘&amp;’ forann variabelnavnet.
Adressen kan deretter lagres i en egen databoks som vi kaller for en peker. En peker har en type, for å vise hvilken type databoks som gjemmer seg bak adressen.</simpara>
<simpara>At databoksen inneholder en peker, angir vi ved å skrive ei stjerne foran variabelen når vi deklarerer den.</simpara>
<programlisting language="c" linenumbering="unnumbered"> char *min_peker_til_a = &amp;a</programlisting>
<literallayout class="monospaced">                        +---------------------+
char *min_peker_til_a = | 9223372036854775808 |
                        +---------------------+</literallayout>
<programlisting language="c" linenumbering="unnumbered"> char b = *min_peker_til_a;</programlisting>
<literallayout class="monospaced">char a og char b inneholder nå begge verdien “h”.</literallayout>
<simpara>Legg merke til dette:</simpara>
<literallayout class="monospaced">9223372036854775808 = min_peker_til_a;
‘h’ = *min_peker_til_a;</literallayout>
<simpara>Altså, om vi skal hente verdien i den databoksen som gjemmer seg bak adressen,
må vi oppgi ei stjerne forann variabelnavnet. Om vi ikke gjør det, henter vi ut selve adressen.</simpara>
<simpara>På samme måte som vi kan ha en tabell av databokser av typen char, kan vi ha en
tabell av databokser av typen <emphasis>peker til char</emphasis>.</simpara>
<simpara>a er en databoks av typen char, som inneholder tegnet ‘h’</simpara>
<programlisting language="c" linenumbering="unnumbered"> char a = ‘h’;</programlisting>
<simpara>b er en databoks av typen <emphasis>tabell av char</emphasis>, som inneholder strengen; “hei”</simpara>
<programlisting language="c" linenumbering="unnumbered"> char b[] = “hei”;</programlisting>
<simpara>Ut fra denne tabellen kan vi hent hver enkel databoks av typen char, slik:</simpara>
<programlisting language="c" linenumbering="unnumbered"> char boks_for_h = b[0];
 char boks_for_e = b[1];
 char boks_for_i = b[2];</programlisting>
<simpara>Det samme kan vi gjøre med datatypen <emphasis>peker til char</emphasis>, slik:</simpara>
<programlisting language="c" linenumbering="unnumbered"> char a = ‘a’
 char b = ‘b’
 char c = ‘c’

 char *pa = &amp;a;
 char *pb = &amp;b;
 char *pc = &amp;c;</programlisting>
<simpara>Disse kan vi legge i en tabell, slik:</simpara>
<programlisting language="c" linenumbering="unnumbered"> char *tabell_av_pekere[] = {pa,pb,pc};</programlisting>
<simpara>på samme måte som da vi opprettet en streng av flere tegn.</simpara>
<simpara>Vi henter ut verdien til det pekeren peker på, ved å sette ei stjerne foran variabelnavnet.</simpara>
<programlisting language="c" linenumbering="unnumbered"> char a2 = *pa</programlisting>
<simpara>eller som i bildet ovenfor, hvor den samme pekeren ligger som første element i en tabell-variabel</simpara>
<programlisting language="c" linenumbering="unnumbered"> char a2 = *tabell_av_peker[0]</programlisting>
<note>
<title>Databokser av ulik type</title>
<simpara>Ok, kjapp oppsummering igjen. En databoks har et navn og en type. Navnet bestemmer
      vi som lager dataprogrammet. Typen er noe som er definert i programmeringsspråket. Vi
      som programmerere velger hvilken type vi ønsker å bruke. En databoks ligger egentlig
      lagret en plass i minnet. Vi har to måter å nå en databoks på. Enten ved å henvise til
      navnet på databoksen, eller ved å bruke en peker som peker mot den adressen hvor databoksen ligger i minnet.</simpara>
</note>
<simpara>Dette er på mange måter kjernen i C-programmering. Det at vi kan programmere med pekere,
som kan peke <emphasis>hvor som helst</emphasis>, gir oss mange muligheter. På godt og ondt.</simpara>
<simpara>Tilbake til main -funksjonen vår. Der har vi at det første argumentet (<emphasis>int argument_antall</emphasis>)
angir antallet input -argumenter, og det andre argumentet (<emphasis>char *argument_vektor[]</emphasis>)
er en tabell av pekere til tekst -strenger. Husk at en tekst -streng er en tabell av databokser av typen char.</simpara>
<simpara>Det betyr at om vi lager oss et program som heter <emphasis>a.exe</emphasis>, som tar inn to tall som parametre, som vist her:</simpara>
<literallayout class="monospaced">a.exe 2 3</literallayout>
<simpara>vil <emphasis>argument_antall</emphasis> og <emphasis>argument_vektor</emphasis>, se slik ut:</simpara>
<literallayout class="monospaced">                      +---+
int argument_antall = | 3 |
                      +---+</literallayout>
<literallayout class="monospaced">                          +-----+-----+-----+
char *argument_vektor[] = | 032 | 040 | 048 |
                          +-----+-----+-----+</literallayout>
<simpara>Hvor det tenkte, litt forenkla, dataminnet ser slik ut:</simpara>
<literallayout class="monospaced">+-----+---------+
| …   |         |
+-----+---------+
| 032 | ‘a.exe’ |
+-----+---------+
| 040 |  ‘2’    |
+-----+---------+
| 048 |  ‘3’    |
+-----+---------+
| …   |         |
+-----+---------+</literallayout>
<simpara>Dette betyr at inne i main -funksjonen vet vi hvor mange argumenter som kommer inn,
og vi vet hvordan vi kan plukke dem ut fra argument_vektor -variabelen.</simpara>
<simpara>Om jeg ønsker å vite hva programmet heter, kan jeg hente det ut slik;</simpara>
<programlisting language="c" linenumbering="unnumbered"> char *a = argv[0]</programlisting>
<simpara>Variablen <emphasis>a</emphasis> vil nå peke mot strengen "a.exe". Det første tallet kan jeg hente ut slik:</simpara>
<programlisting language="c" linenumbering="unnumbered"> char *b = argv[1];
 int t1 = atoi(b);</programlisting>
<simpara>og det andre slik</simpara>
<programlisting language="c" linenumbering="unnumbered"> char *c = *argv[2];
 int t2 = atoi(c);</programlisting>
<simpara>Husk på at det er tekst -strenger vi henter ut fra <emphasis>argument_vektor</emphasis> -tabellen.
Når det gjelder navnet til programmet, altså det første argumentet, så er det
en tekststreng. Denne variabelen er grei. Men, når det gjelder de to tallene må
vi gjøre om datatypen fra char til int. De databoksene vi får ut fra <emphasis>argument_vektor</emphasis>
 er databokser som inneholder en tekst -streng av tallene.
Her kommer funksjonen ‘atoi()’ inn i bildet. Denne funksjonen omgjør en databoks som
innholder en tekstrepresentasjon av et tall, om til en databoks som inneholder en
heltallsrepresentasjon. atoi er et akronym for ascii-to-integer. Om den
tekststrengen som sendes inn til atoi skulle vise seg å ikke innholde et tall, vil
funksjonen retunere verdien null.</simpara>
<simpara>Jeg skal kjapt prøve å forklare litt hva ascii er:</simpara>
<simpara><emphasis>American Standard Code for Information Interchange er en måte å kode bokstaver på.
Husk på at en datamaskin egentlig bare kan forstå tall som er kodet i det binære tallsystemet,
altså kun tallene; null og ett. Ved hjelp av tallene null og ett kan vi kontruere alle heltall,
og vi kan lage systemer for å konstruere desimaltall. På samme måte må vi lage systemer for å
representere tekst. Vi kan for eksempel si at desimal -tallet 65 skal bety bokstaven ‘A’.
Det er nettopp det ascii definerer for oss, samt en rekke andre tegn og bokstaver.</emphasis></simpara>
<simpara>Når du skriver</simpara>
<literallayout class="monospaced">char min_boks = ‘A’</literallayout>
<simpara>legger du <emphasis>egentlig</emphasis> tallet 65 inn i denne boksen.</simpara>
<simpara>65 er ascii-verdien for stor ‘a’. Tilsvarende har vi at ascii -verdien for tegnet ‘2’
er desimaltallet 50. Om vi ønsker å omgjøre teksten ‘2’ om til  tallet to, må vi
bruke konverterings -funksjonen <emphasis>atoi</emphasis>.</simpara>
<simpara>Bottom line her er at du må gjøre om tekst-representasjonen av tallet til
heltalls -representasjonen av tallet, og dette utføres ved hjelp av funksjonen <emphasis>atoi</emphasis>.</simpara>
<simpara>Nå skal vi ha et fiks ferdig <emphasis>C</emphasis>-program som skal kunne legge samme to tall:</simpara>
<formalpara>
<title>test.c (eksempel 6)</title>
<para>
<programlisting language="c" linenumbering="unnumbered"> int main(int argument_antall, char *argument_vektor[]) {

	 if (argument_antall != 3){
        return 0;
     }

	char *a = argument_vektor[0];
	char *b = argument_vektor[1];
	char *c = argument_vektor[2];

	int t1 = atoi(b);
	int t2 = atoi(c);

	return t1 + t2;

 }</programlisting>
</para>
</formalpara>
<simpara>Legg merke til at jeg sjekker innholdet i databoksen <emphasis>argument_antall</emphasis>. Om innholdet
ikke er tallet 3, returnerer jeg tallet 0 for å indikere at brukeren har tastet
inn feil antall argumenter.</simpara>
<simpara>Om innholdet er 3, henter jeg ut de tre argumentene og gjør om de to siste til heltall.
Til slutt adderes disse, og summen blir returnert tilbake til terminalprogrammet.</simpara>
<simpara>Dette er faktisk et ganske fiks ferdig program, takket være den enkle sjekken helt i
starten, hvor vi sjekker at antallet argumenter er 3 før vi går videre.</simpara>
<simpara>Prøv å ta bort denne sjekken, og kjør programmet ut noen inputparametre. Hva skjer?</simpara>
<simpara>(Det som skjer er at vi henter noen databokser; b og c, ut fra minne som <emphasis>ikke eksiterer</emphasis>,
eller ikke tilhører vårt program. Da vil programmet ganske sikkert feile.)</simpara>
<simpara>En lite problem med dette programmet, er at vi antageligvis bare kan
returnere tall opp til 256, eller èn byte. Det vil si at om du legger sammen to tall
hvor summer blir større en 256, vil det tallet som fremkommer på skjermen ikke være rett,
siden du bare vil se den første byten av tallet. Dette har med å gjøre hvordan c-programmet
vårt sender svaret tilbake til terminalprogrammet, og som nevnt så gjør vi det på en veldig minimalistisk måte nå.</simpara>
<simpara>Derfor skal vi innføre en kjekk liten funksjon som heter <emphasis>printf</emphasis>. Denne lar oss selv
skrive ut tallet på skjermen.  <emphasis>printf</emphasis> er så grunnleggende for en rekke programmeringsspråk,
at den har fått sin egen wiki-side på Internett. Dette kommer av at mange programmeringspråk
har behov for å kunne skrive ut en tekststreng på skjermen. I tillegg til selve teksten,
ønsker man som oftes å putte på andre datatyper, typisk tall, i samme slengen. Man formaterer
teksten litt, før den skrives ut. Derav navnet <emphasis>printf</emphasis>, som er en forkortelse for; “<emphasis>print formatert</emphasis>”.</simpara>
<simpara>For å kunne bruke denne funksjonen må du skrive denne linja øverst i kodefila di:</simpara>
<programlisting language="c" linenumbering="unnumbered">#include &lt;stdio.h&gt;</programlisting>
<simpara>På den måten forteller du til kompilatoren at du ønsker å bruke en funksjon som
allerede eksisterer, og at definisjonen på denne ligger i ei fil som heter <emphasis>stdio.h</emphasis></simpara>
<simpara>Om du ønsker å skrive ut en enkel tekst ved help av <emphasis>printf</emphasis>, kan du skrive</simpara>
<programlisting language="c" linenumbering="unnumbered">printf (“Hello world”);</programlisting>
<simpara>Om du ønsker å skrive ut en formatert tekst, må du inn med noen koder.
Med <emphasis>formatert tekst</emphasis> menes at man kan putte inn verdier som ligger i ulike databokser,
inn i tekststrengen, før den skrives ut på skjermen. For eksempel, så har vi sett
at det er mulig å lagre heltall i databokser av typen <emphasis>int</emphasis>. Om vi ønsker å formatere
verdien til en slik databoks, inn i en tekststreng, før denne skrives ut på skjermen,
kan vi gjøre dette slik:</simpara>
<programlisting language="c" linenumbering="unnumbered">int min_boks = 123;

printf (“Verdien til databoksen min_boks er %d”, a);</programlisting>
<simpara>Dette vil resultere i følgende setning på skjermen:</simpara>
<literallayout class="monospaced">Verdien til databoksen min_boks er 123</literallayout>
<simpara>Legg merke til at på samme måte som main er en funksjon som tar inn to parametre,
er også printf en funksjon som tar inn ulike parametre. I vårt tilfelle er disse parametrene en tekststreng og en databoks for heltall.</simpara>
<simpara>Funksjonen <emphasis>printf</emphasis> er laget slik at den bytter ut ulike koder i tekststrengen,
med verdien i de ulike variablene som kommer etter tekststrengen. For eksempel,
om man setter inn denne koden; ‘%d’, så forventer <emphasis>printf</emphasis> at det skal komme en
variabel av typen <emphasis>int</emphasis> like etter tekststrengen.</simpara>
<simpara>Det er mulig å definere flere variabler som skal formateres inn i tekststrengen.
Det er bare å putte på, i rekker og rad:</simpara>
<programlisting language="c" linenumbering="unnumbered"> int a = 123;
 int b = 456;
 printf (“Verdien til a er %d og verdien til b er %d”, a, b);</programlisting>
<simpara>Dette vil resultere i følgende setning på skjermen:</simpara>
<literallayout class="monospaced">Verdien til a er 123 og verdien til b er 456</literallayout>
<simpara>Man kan bruke andre typer databokser, som for eksempel en tabell av chars, som
vi kjenner som en streng. Da må vi bruke koden ‘%s’ som vist her:</simpara>
<formalpara>
<title>test.c (eksempel 7)</title>
<para>
<programlisting language="c" linenumbering="unnumbered"> char a[] = “hei”;

 int b = 2;
 int c = 3;
 int d = b + c;

 printf (“a = %s b = %d c = %d d = %d”, a, b, c, d);</programlisting>
</para>
</formalpara>
<simpara>Vi nærmer oss nå slutte på kapittelet “Innputt &amp; utputt”, hvor vi hovedsakelig
har tatt for oss egenskapene til funksjonen <emphasis>main</emphasis>.</simpara>
<simpara><emphasis>main</emphasis> er funksjonen hvor et <emphasis>C</emphasis>-program starter. Her kommer <emphasis>kallet</emphasis> fra
operativsystemet, og her kan det komme et sett med inputargumenter inn til
programmet vårt. Vi har lært at i alle fall navnet til programmet kommer inn som
argument. Det kan komme flere argumenter. Vi har også lært at <emphasis>main</emphasis>-funksjonen
kan returnere verdien til et heltall, tilbake til operativsystemet. Somregel
brukes denne verdien til å indikere tilbake “<emphasis>hvordan det gikk</emphasis>”; om programmet
feilet, manglet noen inputargumenter etc.</simpara>
<simpara>Helt til slutt viser jeg et komplett eksempel som bruker alt dette.</simpara>
<formalpara>
<title>test.c (eksempel 8)</title>
<para>
<programlisting language="c" linenumbering="unnumbered">#include &lt;stdio.h&gt;

int main(int argc, char *argv[]) {

    char *navn = argv[0];

    if (argc != 3) {
        printf("\nBruk: %s t1 t2 \n", navn);
        printf("\n      hvor t1 og t2 er to heltall ");
        printf("som er &gt; 0\n\n");
        printf("Programmet adderer to tall og ");
        printf("skriver summen ut paa skjermen.\n");
        return 1;
    }

    char *a = argv[1];
    char *b = argv[2];

    int t1 = atoi(a);

    if (t1 == 0) {
        printf("\nFeil: t1 maa vaere et heltall &gt; 0\n");
        return 1;
    }

    int t2 = atoi(b);

    if (t2 == 0) {
        printf("\nFeil: t2 maa vaere et heltall &gt; 0\n");
        return 1;
    }

    int t3 = t1 + t2;
    printf ("Summen av %d og %d er %d\n", t1, t2, t3);

    return 0;

}</programlisting>
</para>
</formalpara>
<simpara>Utover det vi har lært tidligere, ser du at jeg har puttet inn en ny kode i
“format-strengen” til <emphasis>printf</emphasis>. Den nye koden er “\n” som forteller at <emphasis>printf</emphasis> skal skrive ut et linjeskift (new line).</simpara>
<simpara>I tillegg sjekker jeg returverdien til funksjonen <emphasis>atoi</emphasis>. Om denne er null, er det
en viss sannsynlighet for at brukeren ikke har oppgitt et heltall. Han eller hun har i
alle fall ikke oppgitt et heltall som er større enn null, derfor bør man skrive
ut ei feilmelding når det skjer.</simpara>
<simpara>Ta gjerne å eksperimenter med denne kode. Lag et program som kan multiplisere to
tall. Lag  også et program som kan dividere, dvs at t1 blir divident og t2 blir divisor.
Prøv også å skriv ut en litt annen tekst, i starten og slutten av programmet. Jobb litt
med denne koden. Om du synes dette var mye rart å forholde seg til, så kan jeg
trøste deg med at det blir egentlig ikke noe særlig mer komplisert enn dette.</simpara>
</section>
</chapter>
<chapter xml:id="_flytkontroll">
<title>Flytkontroll</title>
<simpara>Nå skal vi se litt på flytkontrollkommandoer. Vi har tidligere snakket om
databokser, som vi kan se på som beholdere av ulike typer data. Nå skal vi ta for
oss hvordan innholdet i disse databoksene, kan være med på å bestemme hva som
skal skje i et dataprogram. Eller sagt på en annen måte; hvordan verdien til en
variabel, er med på å bestemme flyten i programmet.</simpara>
<formalpara>
<title>Læringsmål</title>
<para>
<screen> - kommandoen; if else
 - kommandoen; for
 - kommandoen; while</screen>
</para>
</formalpara>
<simpara>Vi har allerede truffet på <emphasis>if</emphasis> (hvis).</simpara>
<simpara>Hvis “<emphasis>et eller annet</emphasis>”, så “<emphasis>gjør et eller annet</emphasis>”. For eksempel:</simpara>
<literallayout class="monospaced">Databoks b = 3
Hvis b er lik 3, så avslutt programmet.</literallayout>
<simpara>Uttrykt i form av C-kode:</simpara>
<programlisting language="c" linenumbering="unnumbered">int b = 3;
if (b == 3) { return 0; }</programlisting>
<note>
<simpara>Legg merke til at når vi skal tilordne verdien 3 til variabelen <emphasis>b</emphasis>, så bruker
      vi ett likhetstegn, mens når vi skal sjekke om en variabel er lik en verdi,
      bruker vi to likhetstegn etter hverandre.</simpara>
</note>
<simpara>Når man har en <emphasis>hvis</emphasis>, har man ofte også en <emphasis>hvis ikke</emphasis>, som kan kalles <emphasis>ellers</emphasis>.</simpara>
<screen> if (  ‘et eller annet’  )  {

  ‘gjør dette’

 } else {

  ‘ellers gjør dette’

 }</screen>
<simpara>Innholdet i ‘<emphasis>et eller annet</emphasis>’ vil være et logiskt uttrykk som evalurerer til
sant eller ikke sant. Hvor sant = 1 og usant = 0.</simpara>
<simpara>Tenk deg at vi oppretter to databokser av typen heltall, som vi kan kalle
for <emphasis>a</emphasis> og <emphasis>b</emphasis>, og plasserer heltallene 2 og 3 oppi disse, slik:</simpara>
<programlisting language="c" linenumbering="unnumbered">int a = 2;
int b = 3;</programlisting>
<simpara>Deretter oppretter vi en tom databoks av typen heltall, som vi kaller for c, slik:</simpara>
<programlisting language="c" linenumbering="unnumbered">int c;</programlisting>
<simpara>Nå kan vi lage ulike logiske uttrykk hvor vi bruker <emphasis>a</emphasis> og <emphasis>b</emphasis>. Basert på om disse
logiske uttrykkene evaluerer til ‘<emphasis>sant</emphasis>’ eller ‘<emphasis>usant</emphasis>’, kan vi legge ulike
verdier i variabelen c.</simpara>
<simpara>Eksempler på ulike logiske uttrykk vi kan konstruere:</simpara>
<literallayout class="monospaced">Er a lik b?          --&gt; evalurerer til ‘usant’.
Er a ulik b?         --&gt; evalurerer til ‘sant’.
Er a større enn b?   --&gt; evalurerer til ‘usant’.
Er a mindre enn b?   --&gt; evalurerer til ‘sant’.</literallayout>
<simpara>Om vi putter på “litt C-kode” kan vi skrive det slik</simpara>
<literallayout class="monospaced">Er a lik b?        --&gt; if (a == b) --&gt; evalurerer til ‘usant’ --&gt; 0
Er a ulik b?       --&gt; if (a != b) --&gt; evalurerer til ‘sant’  --&gt; 1
Er a større enn b? --&gt; if (a &gt; b)  --&gt; evalurerer til ‘usant’ --&gt; 0
Er a mindre enn b? --&gt; if (a &lt; b)  --&gt; evalurerer til ‘sant’  --&gt; 1</literallayout>
<programlisting language="c" linenumbering="unnumbered"> int a = 1;
 int b = 2;
 int c;

 if (a &gt; b) {
   c = 3;
 } else {
   c = 4;
 }</programlisting>
<simpara>Hvilken verdi har <emphasis>c</emphasis>? 3 eller 4?</simpara>
<simpara>Vi ser at dette egentlig er ganske likt ting og tang vi kjenner fra matematikken.
Det er ikke så rart, siden logikk er ei gren av matematikken. Når vi regner med
bokstaver i matematikken kaller vi det for algebra. Innenfor programmering bruker
vi noe som heter boolsk algebra. Da regner vi med uttrykk, eller regnestykker om du vil,
som evaluerer til ‘<emphasis>sant</emphasis>’ eller ‘<emphasis>usant</emphasis>’.</simpara>
<simpara>Jeg skal prøve å konkretisere dette med noen eksempler.</simpara>
<simpara>Innen vanlig algebra har du at om a = 3 og b = 3, så er a = b <emphasis>sant</emphasis>.</simpara>
<simpara>I boolsk algebra opererer vi kun med ‘<emphasis>sant</emphasis>’ eller ‘<emphasis>ikke sant</emphasis>’. Det betyr i
praksis at det som ikke er sant, må være usant. Om a = 1 (‘<emphasis>sant</emphasis>’) og b = 0 (‘<emphasis>usant</emphasis>’)
så er a != b <emphasis>sant</emphasis>. (!= betyr <emphasis>ikke lik</emphasis>.) Det vil si at uttrykket ‘a er ikke lik b’ er <emphasis>sant</emphasis>. Vi kan
putte tegnet ‘!’ foran et boolsk uttrykk for å invertere det, det vil si gjøre et
<emphasis>sant</emphasis> uttrykk <emphasis>usant</emphasis> og vise versa. !a = b, blir da for eksempel <emphasis>sant</emphasis>.</simpara>
<simpara>Det er kanskje ikke så lurt å dra dette for langt her? Dette er bare et tankesett
som må øves inn. For noen kommer dette lettere enn for andre. Uansett er det bare
litt øving som skal til, så skjønner du dette.</simpara>
<simpara>I tillegg til flyt-kontroll-komandoen ‘<emphasis>hvis</emphasis>’, har vi kommandoen ‘<emphasis>mens</emphasis>’ eller
‘<emphasis>så lenge</emphasis>’.</simpara>
<literallayout class="monospaced">Databoks b = 10
Så lenge b er større enn 10, trekk 1 fra b.</literallayout>
<simpara>I form av <emphasis>C</emphasis>-kode:</simpara>
<formalpara>
<title>test.c (eksempel 9)</title>
<para>
<programlisting language="c" linenumbering="unnumbered">int b = 10;

while ( b &gt; 0 ) {

    b = b - 1;

}</programlisting>
</para>
</formalpara>
<simpara>En slik flyt-kontroll-kommando definerer hva vi kaller for <emphasis>ei løkke</emphasis> eller <emphasis>en loop</emphasis>.
Programmet ovenfor vil gå i ei løkke med 10 iterasjoner, hvor den for hver iterasjon
trekker 1 fra databoksen <emphasis>b</emphasis>.</simpara>
<simpara>Disse to kommandoene; <emphasis>if</emphasis> og <emphasis>while</emphasis>, styrer flyten i programmet. Et
dataprogram er bare en veldig detaljert beskrivelse av hvordan man skal endre på
innholdet i ulike variabler. Det finnes en del flere slike kontrollkommandoer,
men <emphasis>if</emphasis> og <emphasis>while</emphasis> er i særklasse mest brukt. Kanskje bortsett fra en
kommando som er mye brukt for <emphasis>å løpe</emphasis> gjennom en tabell?</simpara>
<simpara>Mange ganger har man bruk for å gjøre ei beregning på en tabell
av data. Om man for eksempel ønsker å gjøre en streng med tekst, om til å kun bestå av
store bokstaver, kan man skrive noe slikt som dette:</simpara>
<formalpara>
<title>test.c (eksempel 10)</title>
<para>
<programlisting language="c" linenumbering="unnumbered">#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

int main() {

    char tekst[] = "Dette er en tekst.";

    int i;
    for(i=0;i&lt;17; i=i+1) {
        tekst[i]=toupper(tekst[i]);
    }

    printf("%s",tekst);

    return 0;
}</programlisting>
</para>
</formalpara>
<simpara>Det eneste som er helt nytt i koden ovenfor, er:</simpara>
<programlisting language="c" linenumbering="unnumbered"> for(i=0;i&lt;17; i=i+1) { }</programlisting>
<simpara>for-løkke-kommandoen består av tre deler, adskilt med semikolon. Den første delen
initialiserer en teller, den andre delen sjekker innholdet i telleren mot en
grenseverdi, og den tredje delen endrer på telleren for hver iterasjon i løkka.</simpara>
<simpara>Derfor er for -løkka mye bruke når man har behov for å gjøre en operasjon på hvert
element i en tabell. <emphasis>while</emphasis> og <emphasis>for</emphasis> gjør mer eller mindre det samme, og de kan
ofte brukes om hverandre.</simpara>
<simpara><emphasis>if</emphasis>, <emphasis>while</emphasis> og <emphasis>for</emphasis> brukes til å styre flyten i et c-program. Basert på
innholdet i en eller flere databokser, kan vi bruke disse kommandoen til å
bestemme hva som skal skje videre i programmet.</simpara>
</chapter>
<chapter xml:id="_struktur">
<title>Struktur</title>
<simpara>Her skal vi se på hvordan vi kan dele opp et program i flere deler. Det å lage
et dataprogram er egentlig å løse et problem eller en oppgave. Problemet løses
som regel, ved å dele hovedproblemet opp i mindre mindre deler som løses hver for seg.
I <emphasis>C</emphasis> gjøres dette ved å lage nye funksjoner, som kalles opp fra <emphasis>main</emphasis>-funksjonen.
Disse ulike funksjonene settes sammen i hva vi kan kalle for en struktur eller et
design, derfor valgte jeg å kalle dette kapitlet for <emphasis>struktur</emphasis>.</simpara>
<formalpara>
<title>Læringsmål</title>
<para>
<screen> - hvordan dele opp et program i flere funksjoner.</screen>
</para>
</formalpara>
<simpara>Vi fortsetter med programmet vårt, som legger sammen to tall. Vi kan si at det å
legge sammen to tall består av tre momenter;</simpara>
<literallayout class="monospaced">-først oppgir vi de to tallene
-deretter utføres det ei beregning, hvor tallene summeres
-og til slutt skal summen presenteres.</literallayout>
<simpara>Vi har allerede brukt funksjonene <emphasis>atoi</emphasis> og <emphasis>printf</emphasis>. Dette er funksjoner som
har utført ganske kompliserte oppgaver for oss. (<emphasis>atoi</emphasis> = ascii to interger,
<emphasis>printf</emphasis> = print formatted) På sammen måte kan vi dele vårt problem opp i
funksjoner som vi lager selv. For eksempel kan vi lage en funksjon, som legger
sammen to tall, slik som dette:</simpara>
<formalpara>
<title>test.c (eksempel 11)</title>
<para>
<programlisting language="c" linenumbering="unnumbered">#include &lt;stdio.h&gt;

int min_funksjon(int a, int b) {

    return a+b;

}

int main() {

    int c = min_funksjon(2,3);

    printf(“c=%d”,c);

    return 0;

}</programlisting>
</para>
</formalpara>
<simpara>Det er ikke noen forskjell mellom de funksjonene som allerede finnes i <emphasis>C</emphasis>, og
de funksjonene vi lager selv. Det eneste vi må huske på er at funksjonen vi
lager selv, må være deklarert ovenfor, eller forann, main-funksjonen, som
vist ovenfor.</simpara>
<simpara>Nedenfor er et litt større eksempel. Her har jeg laget tre funksjoner; en for å
lese inn data, en for å utføre beregningen, og en for å skrive ut resultatet.
I tillegg bruker jeg <emphasis>scanf</emphasis>, som er en standard <emphasis>C</emphasis>-funksjon for å lese inn data
 fra tastaturet, samt <emphasis>printf</emphasis> som vi kjenner fra før.</simpara>
<formalpara>
<title>test.c (eksempel 12)</title>
<para>
<programlisting language="c" linenumbering="unnumbered">#include &lt;stdio.h&gt;

void min_innputt(char *tekst, int *data) {

    printf("%s",tekst);
    scanf("%d",data);

}

int min_beregning(int a, int b) {

    return a+b;

}

void min_utputt(int a, int b, int c) {

    printf("%d + %d = %d\n",a,b,c);

}

int main() {

    int a,b,c;                              <co xml:id="CO4-1"/>

    min_innputt("Oppgi et tall, a: ",&amp;a);   <co xml:id="CO4-2"/>
    min_innputt("Oppgi et tall, b: ",&amp;b);   <co xml:id="CO4-3"/>

    c = min_beregning(a,b);                 <co xml:id="CO4-4"/>

    min_utputt(a,b,c);                      <co xml:id="CO4-5"/>
    return 0;

}</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO4-1">
<para>Definerer tre variabler/databokse for heltall.</para>
</callout>
<callout arearefs="CO4-2">
<para>Ved hjelp av funksjonen <emphasis>min_innputt</emphasis> leser vi inn en verdi i <emphasis>a</emphasis></para>
</callout>
<callout arearefs="CO4-3">
<para>Ved hjelp av funksjonen <emphasis>min_innputt</emphasis> leser vi inn en verdi i <emphasis>b</emphasis></para>
</callout>
<callout arearefs="CO4-4">
<para>Ved hjelp av funksjonen <emphasis>min_beregning</emphasis> kalkulerer vi: <emphasis>c = a + b</emphasis></para>
</callout>
<callout arearefs="CO4-5">
<para>Ved hjelp av funksjonen <emphasis>min_utputt</emphasis> skriver vi ut <emphasis>c</emphasis> til skjerm.</para>
</callout>
</calloutlist>
<simpara>Vi skal ta for oss hver funksjon, og se nærmere på hva den gjør.</simpara>
<formalpara>
<title>Funksjonen <emphasis>main()</emphasis></title>
<para>Dette er vår gode gamle <emphasis>main</emphasis>-funksjon. Her starter programmet. Det første
som skjer er at vi definerer tre variabler. Deretter bruker vi tre
funksjoner for å utføre det vi ønsker å gjøre. Til slutt returnerer vi tallet null
tilbake til operativsystmet.</para>
</formalpara>
<formalpara>
<title>Funksjonen <emphasis>min_beregning()</emphasis></title>
<para>Funksjonen tar inn to tall, og returnerer med summen av disse.</para>
</formalpara>
<formalpara>
<title>Funksjonen <emphasis>min_utputt()</emphasis></title>
<para>Funksjonen tar inn tre heltall; a, b, c. Ved hjelp av funksjonen <emphasis>printf</emphasis> flettes
disse tallene inn i en formatert tekststreng, og skrives ut på skjermen.</para>
</formalpara>
<formalpara>
<title>Funksjonen <emphasis>min_innputt()</emphasis></title>
<para>Dette er kanskje den mest avanserte funksjonen, siden den tar inn to pekere. En peker
er som nevnt en spesiell type variabel, som inneholder minneadressen til den aktuelle
databoksen.</para>
</formalpara>
<simpara>Den første pekeren inneholder adressen til en <emphasis>char</emphasis>-variabel. Og som
nevnt, så består en tekststreng av en rekke <emphasis>char</emphasis>-variabler etter hverandre, som avsluttes med
tallet null. Dermed holder det for <emphasis>printf</emphasis>-funksjonen å få inn en <emphasis>char</emphasis>-peker til det
første tegnet i strengen. <emphasis>printf</emphasis> kan da bytte ut <emphasis>%s</emphasis> med strengen som <emphasis>test</emphasis> peker på.</simpara>
<screen> char *p = "en streng"

              0   1   2   3   4   5   6   7   8   9
            +---+---+---+---+---+---+---+---+---+---+
 char *p =&gt; | e | n |   | s | t | r | e | n | g | 0 |
            +---+---+---+---+---+---+---+---+---+---+

 char *p vil innholde minneadressen til 'e'</screen>
<simpara>Bare for å øke forvirrelsen ytterligere rundt det med <emphasis>char</emphasis>-pekere, så kan det nevnes her
at vi kunne brukt en vanlig tabell av <emphasis>char</emphasis> også. Da måtte funksjonen sett slik ut:</simpara>
<literallayout class="monospaced">void min_innputt(char tekst[], int *data) {
   printf("%s",tekst);
   scanf("%d",data);
}</literallayout>
<simpara>Dette kommer av at for oss, her og nå, så er dette det samme:</simpara>
<literallayout class="monospaced">char *p = "en streng"
char p[] = "en strenng"</literallayout>
<simpara>men, egentlig blir strengen lagret på litt ulikt vis. Men, som sagt, for oss har det
ingen praktisk betyning.</simpara>
<simpara>Den neste pekeren som kommer inn til funksjonen <emphasis>min_innputt</emphasis>, er en peker til en
heltallsvariabel, kalt data. I dette tilfellet har vi ikke noe valg, vi må sende inn
en peker. Grunnen til dette er at funksjonen <emphasis>scanf</emphasis> skal lagre et heltall på denne
adressen. På den måten kan andre funksjone senere hente ut innholdet som gjemmer seg
bak denne adressen. Her ligger på sett og vis litt av essensen, eller kjernen, i <emphasis>C</emphasis>-programmering
gjemt. Men, det kan være litt vanskelig å forstå, så jeg skal prøve å ta det stegvis.</simpara>
<simpara>I hovedfunksjonen <emphasis>main</emphasis> blir det opprettet en variabel, kalt <emphasis>a</emphasis>. Denne har en
type, en verdi og en adresse. Typen er <emphasis>int</emphasis>. Verdien er i utgangspunktet en vilkårlig verdi.
Men, adressen er fast. Vi kan for eksempel si at adressen er 1234.</simpara>
<simpara>Når vi skriver <emphasis>&amp;a</emphasis> henter vi ut adressen til variabelen. Denne adressen lagrer vi i en
peker. Husk at:</simpara>
<literallayout class="monospaced">int a;
int *peker_til_a = &amp;a;</literallayout>
<simpara>Det er denne pekeren som kommer som innput til funksjonen <emphasis>min_innputt</emphasis>. Når vi har
denne adressen, kan vi bruke den til å lagre en heltallsverdi på denne adressen. Det
er nettopp det som skjer i funksjonen <emphasis>scanf</emphasis>. Når funksjonen <emphasis>min_innputt</emphasis> returnerer tilbake
til hovedfunksjonen <emphasis>main</emphasis>, vil innholdet i variabelen <emphasis>a</emphasis> ha blitt endret. På grunn av at vi
brukte en peker til en variabel, klarte vi å endre innholdet på denne.
Altså innholdet i <emphasis>a</emphasis> ble endret av funksjonen <emphasis>scanf</emphasis>, som ble kalt opp av funksjonen
<emphasis>min_innputt</emphasis> som ble kalt opp av <emphasis>main</emphasis>, hvor <emphasis>a</emphasis> ble definert. Det er nettopp dette som
er styrken ved å bruke pekere; man tar med seg en referanse til en variabel, og kan hent ut
verdien og eller oppdatere denne, hvor som helst.</simpara>
<formalpara>
<title>Oppsummering</title>
<para>Nå har vi lært litt om databokser, også kalt for variabler, som vi bruker
for å lagre data. Vi har lært at det er ulike typer data og vi har sett på
heltall (kalt for <emphasis>int</emphasis>) og tegn (kalt for <emphasis>char</emphasis>). Vi har også sette på
flyt-kontroll-kommandoer, som vi bruker for å styre flyten i programmet. Tre
eksempler på kontrollkommandoer er <emphasis>if</emphasis>, <emphasis>while</emphasis> og <emphasis>for</emphasis>. Disse styrer flyten i
programmet, baset på innholdet i en eller flere databokser. Tilslutt har vi sett
på hvordan vi kan dele et program opp i flere mindre program som vi kaller for
funksjoner. Og vi har sett på hvordan vi kan bruke pekere for å dele på data
mellom ulike funksjoner.</para>
</formalpara>
<simpara>Det å lære seg et programmeringsspråk er ganske likt det å lære seg et
talespråk. Man må bruke språket, for å få det inn i
fingrene. Derfor skal vi runde av dette kapitlet med et rikholdig eksempel. Dette
eksempelet må du eksperimentere litt med selv. Det er et program
hvor du kan velge mellom å addere eller multiplisere to tall. Det er bare litt mer avansert,
enn eksempelet ovenfor, så jeg tror du skjønner hva som skjer. Prøv å gjør ulike
endringer på dette programmet.</simpara>
<formalpara>
<title>test.c (eksempel 13)</title>
<para>
<programlisting language="c" linenumbering="unnumbered">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void min_input(char *tekst, int *data) {

    printf("%s",tekst);
    scanf("%d",data);

}

int meny() {

    int valg;
    int valg_ok = 0;

    while (valg_ok == 0) {

        printf("\nVelg 1 for aa avslutte\n");
        printf("Velg 2 for aa legge sammen to tall, a + b\n");
        printf("Velg 3 for aa multiplisere to tall, a x b\n");
        printf("\n");

        min_input("Velg:",&amp;valg);

        if (valg == 1 || valg == 2 || valg == 3) {

            return valg;

        } else {

            printf("Ugyldig valg, velg 1, 2 eller 3\n");

        }
    }

}

int min_beregning(int a, int b, int type) {

    if (type == 2) {

        return a+b;

    } else if (type == 3) {

        return a*b;

    } else {

        return 0;

    }

}

void min_output(int a, int b, int c, int type) {

    char t;

    if (type == 2) {

        t = '+';

    } else if (type == 3) {

        t = '*';

    }

    printf("\n%d %c %d = %d\n",a,t,b,c);

}

int main() {           <co xml:id="CO5-1"/>

    int a,b,c,v;       <co xml:id="CO5-2"/>

    while (1) {        <co xml:id="CO5-3"/>

        v = meny();    <co xml:id="CO5-4"/>

        if (v == 1)    <co xml:id="CO5-5"/>
            return 0;

        min_input("\nOppgi et tall, a: ",&amp;a);  <co xml:id="CO5-6"/>
        min_input("Oppgi et tall, b: ",&amp;b);    <co xml:id="CO5-7"/>

        c = min_beregning(a,b,v); <co xml:id="CO5-8"/>

        min_output(a,b,c,v);      <co xml:id="CO5-9"/>

    }

}</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO5-1">
<para>Her starter programmet.</para>
</callout>
<callout arearefs="CO5-2">
<para>Fire databokser som kan inneholde heltatt, defineres.</para>
</callout>
<callout arearefs="CO5-3">
<para>Her går vi inn i en evigvarende løkke. 1 er alltid <emphasis>sant</emphasis> :-)</para>
</callout>
<callout arearefs="CO5-4">
<para>Funksjonen <emphasis>meny</emphasis> kalles opp, og returnerer med en verdi som legges i <emphasis>v</emphasis></para>
</callout>
<callout arearefs="CO5-5">
<para>Om denne verdien er lik 1, avslutter vi vårt program.</para>
</callout>
<callout arearefs="CO5-6">
<para>Funksjonen <emphasis>min_innputt</emphasis> kalles opp, med to parametre.</para>
</callout>
<callout arearefs="CO5-7">
<para>Funksjonen <emphasis>min_innputt</emphasis> kalles opp, med to andre parametre.</para>
</callout>
<callout arearefs="CO5-8">
<para>Funksjonen <emphasis>min_beregning</emphasis> kalles opp, med tre parametre.</para>
</callout>
<callout arearefs="CO5-9">
<para>Funksjonen <emphasis>min_utputt</emphasis> kalles opp, med fire parametre.</para>
</callout>
</calloutlist>
</chapter>
<chapter xml:id="_moduler">
<title>Moduler</title>
<simpara>Hittil har vi sett på det mest grunnleggende rundt <emphasis>C</emphasis>-programmering. Men, allerede
har vi erfart at det fort blir mange slike variabler og funksjoner. Hvor mange variabler
og funksjoner som må opprettes, er en av mange vurderinger som må gjøres når man
lager et dataprogram. Hva skal de ulike variablene hete? Hva skal de inneholde
av data? Hvilke funksjoner trenger vi for å utføre de beregningene som må til for
at programmet vårt skal gjøre det vi ønsker? Alt dette blir raskt komplekst. Derfor
handler mye omkring programmering å finne ulike teknikker for å handtere kompleksitet.
 Det finnes det en rekke metoder og strategier for å
handtere denne kompleksiteten. En metode er å dele koden opp i ulike moduler
med hensyn til hvilke variabler som er synlige.</simpara>
<formalpara>
<title>Læringsmål</title>
<para>
<screen> - lære hva scope er</screen>
</para>
</formalpara>
<section xml:id="_scope">
<title>Scope</title>
<simpara>Et triks for å handtere kompleksitet er å innføre begrepet; <emphasis>scope</emphasis>.</simpara>
<simpara>Hva er <emphasis>scope</emphasis>?</simpara>
<simpara><emphasis>scope</emphasis> er det området du ser, eller noe er synlig innenfor. Dette begrepet er
relevant når vi snakker om variabler. Når du lager et
dataprogram av en viss størrelse, vil du etterhvert opprette mange variabler.
Disse variablene må ha sitt unike navn. Så hvordan fikser vi det?</simpara>
<simpara>Tenk deg en adresse. Tenk deg at du har gateadressen; <emphasis>“Hjemvegen 123”</emphasis>. Dette er
ikke en veldig unik adresse. Antageligvis er det mange andre som har
samme adressen, bare andre steder. De har samme adressen, bare med andre
postnummer. Vi kan godt tenke oss at det for eksempel finnes to ulike postnummer,
hvor denne gateadressen finnes:</simpara>
<literallayout class="monospaced">Hjemvegen 123
1234 HER</literallayout>
<literallayout class="monospaced">Hjemvegen 123
5678 DER</literallayout>
<simpara>De to gateadressene ligger i to ulike <emphasis>scope</emphasis>. To ulike synsfelt. To ulike områder.
I hvert sitt synsfelt er de to gateadressene unike. Relatert til <emphasis>C</emphasis> og
variabler, blir bildet slik:</simpara>
<formalpara>
<title>test.c (eksempel 14)</title>
<para>
<programlisting language="c" linenumbering="unnumbered">int funk() {
    int hjemvegen123 = 1;
    return hjemvegen123;
}

int main() {
    int hjemvegen123 = 2;
    printf(“%d %d”,hjemvegen123, funk());
    return 0;
}</programlisting>
</para>
</formalpara>
<simpara>Siden de to variablene ligger i to ulike <emphasis>scope</emphasis>, kan de godt hete det samme. Det
er likevel to unike variabler.</simpara>
<simpara>Klammeparantestegnene {} definerer et
<emphasis>scope</emphasis> i <emphasis>C</emphasis>.</simpara>
<simpara>Det betyr at vi kan lage konstruksjoner som dette</simpara>
<formalpara>
<title>test.c (eksempel 15)</title>
<para>
<programlisting language="c" linenumbering="unnumbered">int main() {
    int hjemvegen123 = 2;
    for (int i=0; i&lt;5; i=i+1) {
        int hjemvegen123 = 3;
        printf(“%d”,hjemvegen123);
    }
    printf(“%d”,hjemvegen123);
    return 0;
}</programlisting>
</para>
</formalpara>
<simpara>Dette vil resultere i utskrifta:</simpara>
<literallayout class="monospaced">333332</literallayout>
<simpara>Eller forklart i <emphasis>C</emphasis> kode, i sin enkleste form</simpara>
<formalpara>
<title>test.c (eksempel 16)</title>
<para>
<programlisting language="c" linenumbering="unnumbered">int main() {
    int a = 2;
    {
        int a = 3;
        printf(“%d”,a);
    }
    printf(“%d”,a);
    return 0;
}</programlisting>
</para>
</formalpara>
<simpara>Dette vil resultere i utskrifta:</simpara>
<literallayout class="monospaced">32</literallayout>
<simpara>Vi styrer altså synligheten til de ulike variablene ved å definere ulike <emphasis>scope</emphasis>. Jeg
er klar over at dette kan virke litt rart akkurat nå. Men, årsaken til at jeg
stresser dette, er at etter hvert vil vi kanskje ha tusenvis av slike variabler.
Derfor er det viktig å vite hvordan vi handterer dette. Det å vite at en variabel
kun er synlig innenfor sitt <emphasis>scope</emphasis>, er fundamental kunnskap.</simpara>
<simpara>Vi har sett på disse typene <emphasis>scope</emphasis> så langt:</simpara>
<screen> void funk()
 {

     ‘dette er et scope, kalt f.eks A’

 }

 int main()
 {

    ‘dette er et scope, kalt f.eks B’

    {

        ‘dette er et scope, kalt f.eks C’

    }

    ‘dette er et scope, kalt f.eks B’ (samme som B ovenfor)

 }</screen>
<simpara>Dette er èn type <emphasis>scope</emphasis>. De er alle definerte ved hjelp av
klammeparanteser. Slike scope kan du definere hvor mange du vil.</simpara>
<simpara>Det finnes ytterligere to typer <emphasis>scope</emphasis>; en type <emphasis>scope</emphasis> som er global
for hele programmet, og en type <emphasis>scope</emphasis> som kun gjelder for den aktuelle kodefila <footnote><simpara>kompileringsenhet; kodefila pluss headerfiler</simpara></footnote>.</simpara>
<simpara>La oss først ta det <emphasis>globale scopet</emphasis>.</simpara>
</section>
<section xml:id="_globalt_scope">
<title>Globalt scope</title>
<simpara>Legg merke til at alle variablene vi har definert så langt, har hele tiden
vært definert mellom to klammeparanteser. Klammeparantesene har definert scopet
til variabelen; enten ved å definere variabelen inne i en eller annen funksjon,
eller ved å definere variabelen inne ei <emphasis>if</emphasis>-blokk, <emphasis>while</emphasis>-blokk eller <emphasis>for</emphasis>-blokk.</simpara>
<simpara>Her kommer det snedige; om vi definerer en variabel utenfor ei slik blokk, blir
variabelen hva vi kaller for <emphasis>global</emphasis>. Det vil si at vi kan bruke den hvor som helst i
programmet. Men, da må også navnet være unikt for hele programmet. Vi kan for
eksempel ikke ha to globale variabler som vi kaller for <emphasis>‘a’</emphasis>. Alle globale variabler
må ha et unikt navn, siden de er; &#8230;&#8203; globale.</simpara>
<simpara>Dette er helt analogt til eksempelet med postadresser. Om vi ikke hadde hatt
postnummer, så måtte alle gateadressene vært unike. Nedenfor er et eksempel som
viser hvordan en global variabel fungerer:</simpara>
<formalpara>
<title>test.c (eksempel 17)</title>
<para>
<programlisting language="c" linenumbering="unnumbered">#include &lt;stdio.h&gt;

int a = 1;

void funk1() {
    printf("%d",a);
}

void funk2() {
    int a = 2;
    printf("%d",a);
}

int main() {
    funk1();
    funk2();
    printf("%d",a);
    {
        int a=3;
        printf("%d",a);
    }
    return 0;
}</programlisting>
</para>
</formalpara>
<simpara>Dette programmet vil skrive ut</simpara>
<literallayout class="monospaced">1213</literallayout>
<simpara>Legg merke til at den globale variablen <emphasis>a</emphasis> blir bruke både i <emphasis>funk1</emphasis> og i <emphasis>main</emphasis>.
Legg også merke til at den globale variabelen <emphasis>a</emphasis> ikke er avgrenset av noen klammeparanteser.</simpara>
</section>
<section xml:id="_statiske_variabler_kompileringsenhetsscope">
<title>Statiske variabler (kompileringsenhetsscope)</title>
<simpara>Den tredje og siste, typen <emphasis>scope</emphasis> vi skal se på, er relatert til noe som kalles
statiske variabler.</simpara>
<simpara>En statisk variabel opprettes ved å skrive kommandoen
<emphasis>static</emphasis> forann variabeldefinisjonen. For å forstå hvordan dette er relatert
til <emphasis>scope</emphasis>, må vi først se litt på hvordan vi kan dele et <emphasis>C</emphasis>-program opp i
flere kodefiler.</simpara>
<simpara>Vi har sett at vi kan dele et programm opp i flere funksjoner. Alt starter i <emphasis>main</emphasis>, og herfra
kan vi kalle opp andre funksjoner, også funksjoner som vi lager selv. De funksjonene vi ikke
selv har laget, har vi importert til programmet vårt ved hjelp av kodelinja:</simpara>
<literallayout class="monospaced">#include &lt;stdio.h&gt;</literallayout>
<simpara>En viktig strategi for å handtere kompleksiteten, er å dele koden opp i flere tekstfiler.
På samme måte som de ulike innebygde funksjonene i <emphasis>C</emphasis> ligger i ulike kodefiler, kan vi
legge våre egene funksjoner i ulike kodefiler. På den måte kan vi få en viss oversikt
og stuktur. Dette er helt avgjørende for å kunne lage store og omfattende program.
De fleste programmeringsspråk støtter dette trikset for å håndtere kompleksitet, også <emphasis>C</emphasis>.</simpara>
<simpara>Så, hvordan går vi frem for å dele programmet vårt opp i flere filer?</simpara>
<simpara>For å forstå dette, må vi se litt nærmere på hvordan <emphasis>C</emphasis>-kompilatoren omgjør vår kode til maskinkode.</simpara>
<simpara>Vi har allerde sett at vi kan inkludere andre filer i vår egen kodefil ved å skrive
slikt som dette:</simpara>
<literallayout class="monospaced">#include &lt;stdio.h&gt;</literallayout>
<simpara>I <emphasis>stdio.h</emphasis> vil deklareringen til f.eks <emphasis>printf</emphasis>-funksjonen ligge. Selve koden, som vi
kan kalle for definisjonen, ligger en annen plass, eller rettere i ei anna fil. Og nå
er vi ved kjernen i noe som er litt sentralt i mange programeringsspråk; det er forskjell
på <emphasis>å deklarere</emphasis> noe og <emphasis>å definere</emphasis> noe.</simpara>
<simpara>Jeg skal vise forskjellen med et konkret eksempel:</simpara>
<programlisting language="c" linenumbering="unnumbered">int funk(int a, int b) {
    int c = a + b;
    return c;
}

int main() {
    int a = funk(2,3);
    printf(“%a”,d);
    return 0;
}</programlisting>
<simpara>Vi kjenner igjen dette oppsettet. Her definerer vi vår egen funksjon, som vi
anvender i hovedfunksjonen <emphasis>main</emphasis>. Vi vet også at om denne ikke ble plassert
ovenfor <emphasis>main</emphasis>, så vil kompilatoren feile med en eller annen feilmelding. (Prøv
gjerne ut dette i praksis.)</simpara>
<simpara>Om jeg absolutt vil plassere den nye funksjonen nedenfor <emphasis>main</emphasis>-funksjonen, må jeg <emphasis>deklarere</emphasis>
den nye funksjonen først. Dette må jeg gjøre for at kompilatoren skal kjenne igjen funksjonen,
når den treffer på denne i <emphasis>main</emphasis>. Måten vi gjør dette på, er som følger:</simpara>
<formalpara>
<title>test.c (eksempel 18)</title>
<para>
<programlisting language="c" linenumbering="unnumbered">int funk(int a, int b);

int main() {
    int a = funk(2,3);
    printf(“%a”,d);
    return 0;
}

int funk(int a, int b) {
    int c = a + b;
    return c;
}</programlisting>
</para>
</formalpara>
<simpara>Her har jeg deklarert <emphasis>signaturen</emphasis> til funksjonen, slik at når kompilatoren kommer
ned i <emphasis>main</emphasis>-funksjonen og treffer på vår funksjon, så vet denne hva som kreves av
innputt-parametre og hva som returneres. Legg merke til at kombinasjonen av returverdi, navn og
inputverdier til en funksjon, alltid vil være unik. Derfor kaller vi dette
for <emphasis>signaturen</emphasis> til funksjonen. Selve <emphasis>definisjonen</emphasis>, altså innholdet i funksjonen, kan
nå kommer senere, dvs etter <emphasis>main-funksjonen</emphasis>.</simpara>
<simpara>Nå kan vi velge å lage to nye kodefiler. La oss kalle disse for <emphasis>funk.h</emphasis> og <emphasis>funk.c</emphasis>.
I <emphasis>funk.h</emphasis> legger vi <emphasis>deklarasjonen</emphasis> av funksjonen. Og i <emphasis>funk.c</emphasis> legger <emphasis>definisjonen</emphasis>:</simpara>
<formalpara>
<title>funk.h</title>
<para>
<programlisting language="c" linenumbering="unnumbered">int funk(int a, b);</programlisting>
</para>
</formalpara>
<formalpara>
<title>funk.c</title>
<para>
<programlisting language="c" linenumbering="unnumbered">int funk(int a, int b) {
    int c = a + b;
    return c;
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>test.c (eksempel 19)</title>
<para>
<programlisting language="c" linenumbering="unnumbered">#include &lt;stdio.h&gt; /* For printf */
#include &lt;funk.h&gt;  /* For funk */

int main() {
    int a = funk(2,3);
    printf(“%d”,a);
    return 0;
}</programlisting>
</para>
</formalpara>
<simpara>For å kompilere denne koden, må vi nå skrive:</simpara>
<literallayout class="monospaced">gcc -I . funk.c test.c</literallayout>
<simpara>hvor vi oppgir de to kodefilene våre, som nå er <emphasis>funk.c</emphasis> og <emphasis>test.c</emphasis>, samt at vi
med parameteren “-I.” forteller kompilatoren at den skal lete etter <emphasis>“inklude-filer”</emphasis> i samme
katalog som vi starter kompilatoren i. En prikk, eller punkum, angir den filkatalogen
du står i.</simpara>
<simpara>Ok, her ble det mye hokus pokus, og du bør egentlig nå lurer på hvorfor vi trenger
alt dette styret. Det som engang var en ganske oversiktelig kode, er nå blitt en
mye mikk makk, spredd over flere filer. Noe som igjen medfører at det å kompilere
koden blir mer komplisert.</simpara>
<simpara>Åraken til at vi splitter opp programmet på denne måten,
er for å kunne handtere kompleksitet.</simpara>
<simpara>Husk på at et dataprogram fort kan bli flere
tusen linjer med kode, og dette bør vi stukturere i ulike filer for å holde en viss
oversikt. Som regel plasserer vi funksjoner som hører sammen, i egne filer. På den
måten får vi en struktur. Og det blir lettere å forstå hvordan koden henger sammen.</simpara>
<simpara>Et dataprogram består av mange deler. En god del av disse delene er kode som vi ikke
har laget selv. Denne koden som andre har laget, kan vi benytte oss av i to former;
enten som ren kodetekst, hvor vi selv kompilerer denne om til maskinkode, eller
som binær-kode hvor koden allerede er kompilert om til maskinkode. For å forstå litt
mer av denne prosessen må vi se litt nærmere på hva som skjer når vi kompilerer.</simpara>
<literallayout class="monospaced">gcc -I . funk.c test.c</literallayout>
<simpara>Det som skjer ovenfor er egentlig to operasjoner. Først blir de to filene kompilert
om til maskinkode, eller mer korrekt; objektfiler. Deretter blir de linket, satt sammen,
til ei såkalt kjørbar fil, her kalt a.exe</simpara>
<screen> gcc -c funk.c
 gcc -I. -c test.c
 gcc funk.o test.o</screen>
<simpara>Som regel ønsker vi å gi et mer beskrivende navn til den kjørbare fila. Dette kan
vi gjøre slik:</simpara>
<literallayout class="monospaced">gcc funk.o test.o -o mittprogram</literallayout>
<simpara>Dette vil produsere ei fil som heter mittprogram.exe</simpara>
<simpara>Det er viktig å vite at det å bygge et <emphasis>C</emphasis>-program består av to steg: kompilering
og linking. Når man kompilerer, gjør man ei kodefil (som kan bestå av flere filer
vha “#include”) om til ei objektfil. Ei objektfil inneholder maskinkode for akkurat
din type datamaskin. Deretter settes  objekt-filene sammen til ei kjørbar fil. Denne
fila representerer programmet ditt.</simpara>
<simpara>Siden et program består av veldig mange kodelinjer, vil man ofte komme opp i
situasjoner hvor det er lurt å gjennbruke eksisterende kode. Somregel er store
deler av et programm nettopp slik gjenbruk av eksisterende koden, siden de aller
fleste program har felles funksjonalitet i større eller mindre grad.</simpara>
<simpara>Om vi skulle ønske å gjenbruke den funksjonen som vi lagde ovenfor, hvordan skulle
vi gå frem? Jo, vi har jo allerede lagt både deklarasjonen (funk.h) og koden (funk.c) i to
egne filer. Alt vi
trenger å gjøre er å lage en ny <emphasis>main</emphasis>-funksjon. Dette kan vi gjøre ved å opprette
ei fil som vi kaller for <emphasis>test2.c</emphasis></simpara>
<formalpara>
<title>test2.c</title>
<para>
<programlisting language="c" linenumbering="unnumbered">#include &lt;stdio.h&gt; /* For printf */
#include &lt;funk.h&gt;  /* For funk */

int main() {
    int a = funk(2,3);
    printf(“Test 2 funk(2,3)=%d”,a);
    return 0;
}</programlisting>
</para>
</formalpara>
<simpara>Kompiler ditt nye program slik</simpara>
<literallayout class="monospaced">gcc -I . -c test2.c</literallayout>
<simpara>Link ditt nye program, med vår gamle funksjon, som fortsatt ligger i <emphasis>funk.o</emphasis> -fila, slik:</simpara>
<literallayout class="monospaced">gcc funk.o test2.o</literallayout>
<simpara>Du får nå få opprettet fila <emphasis>a.exe</emphasis>. Om du kjører denne vil du få følgende ut på skjermen:</simpara>
<literallayout class="monospaced">Test 2 funk(2,3)=5</literallayout>
<simpara>Det du nettopp utførte, var å gjenbruke et kodebibliotek kalt <emphasis>funk.o</emphasis>.  Altså kode
som eksiterte fra før. Vi kan gjerne kalle dette for en modul. Dette trikset gjør
det mulig å bygge utrolig komplekse dataprogram, siden vi gjerne baserer oss på kode som andre har laget.</simpara>
<simpara>En ting er at du kan gjenbruke kode. Det er i seg selv lurt. Men, kanskje er den
aller største gevinsten at du ikke trenger å vite hvordan innholdet i en modul er kodet.
Du trenger bare å vite hvordan du skal bruke den. Dette gjør at du kan <emphasis>abstrahere</emphasis> deg fra
detaljer som ikke er relevant for din problemstilling.</simpara>
<simpara>Litt lengre ut i boka skal vi lage et enkelt spill. Her kommer vi til å ta i bruk et
kodebibliotek som heter SDL (Simple Directmedia Layer). Dette kodebiblioteket vil ta seg
av mye av jobben rundt det å vise grafikk på skjermen, samt det å motta innputt. Dermed
kan vi abstrahere oss bort fra alle detaljene rundt dette.</simpara>
<simpara>Dette delkapitlet heter <emphasis>statiske variabler (kompileringsenhetsscope)</emphasis>. Nå har vi nok
grunnlag til å kunne forstå denne aller siste typen <emphasis>scope</emphasis>.</simpara>
<simpara>Vi husker at en variabel kunne ha forskjellige <emphasis>skope</emphasis>. Dette skopet var i stor grad
styrt av klammeparanteser. Innenfor et <emphasis>skope</emphasis> måtte variabelnavnet
være unikt. Om vi plassert en variabel på utsiden av enhver klammeparantes, ble den hva
vi kaller en global variabel. Da kan du nå den, eller bruke den, i hele progammet, når
som helst.</simpara>
<simpara>Det betyr i praksis, at om vi tar å definerer oss en global variabel i fila <emphasis>funk.c</emphasis>, så vil
den også kunne benyttes i kode som vi skriver i fila <emphasis>test2.c</emphasis> Dette vil som regel
ikke være ønskelig. I slike tilfeller vil man ofte ønske at den globale variablen kun
skal være synlig for kode relatert til fila <emphasis>funk.c</emphasis> For å få dette til, skriver man
bare kommandoen <emphasis>static</emphasis> forann variabelen eller funksjonen. Da vil skopet til den
aktuelle variablen eller funkjonen, bli den aktuelle kodefila med
tilhørende <emphasis>include</emphasis>-filer.</simpara>
<simpara>Nå er vi inne på litt finurlige greier. Men, dette er viktig å kunne noe om, når man
skal lage litt større dataprogram.</simpara>
<simpara>Jeg skal konkretisere dette trikset med et eksempel.</simpara>
<simpara>Tenk deg at vi har laget et kodebiliotek bestående av en funksjon. Funksjonen tar
inn to tall og returnerer med et nytt tall mellom 0 og 100. Tallet som returneres
angir sannsynligheten for at begge innputt-tallene inngår i neste ukes lottorekke.</simpara>
<simpara>Da vil <emphasis>funk.h</emphasis> og <emphasis>funk.c</emphasis> kunne se slik ut:</simpara>
<formalpara>
<title>funk.h</title>
<para>
<programlisting language="c" linenumbering="unnumbered">int funk(int a, int b);</programlisting>
</para>
</formalpara>
<formalpara>
<title>funk.c (eksempel 19)</title>
<para>
<programlisting language="c" linenumbering="unnumbered">static int hemmelig_funksjon(int a, int b) {
    return 50;
}

int funk(int a, int b) {
    int c = hemmelig_funksjon(a,b);
}</programlisting>
</para>
</formalpara>
<simpara>Et program som benytter koden vår (eller vårt kodebilliotek) kan se slik ut:</simpara>
<formalpara>
<title>test2.c (eksempel 20)</title>
<para>
<programlisting language="c" linenumbering="unnumbered">#include &lt;stdio.h&gt;
#include &lt;funk.h&gt;

int main() {
    int a = funk(2,3);
    printf(“%d”,a);
    return 0;
}</programlisting>
</para>
</formalpara>
<simpara>Det at jeg skriver <emphasis>static</emphasis> forann funksjonen <emphasis>‘hemmelig_funskjon’</emphasis>, gjør at
denne blir usynlig for kode som er definert i <emphasis>test2.c</emphasis></simpara>
<simpara>Det igjen muligjør også at vi i <emphasis>test2.c</emphasis>, kan lage vår egen funksjon som har akkurat
samme signatur.</simpara>
<simpara>Dette trikset gjør at det blir vesentlig lettere å lage komplekse dataprogram, siden
variabler og funksjoner kan ha sitt <emphasis>scope</emphasis> innenfor en modul eller kodebibliotek.</simpara>
<simpara>I C++ og Java omtales slike variabler og funksjoner som <emphasis>“private</emphasis>”, innenfor sin modul.</simpara>
<formalpara>
<title>Oppsummering</title>
<para>Årsaken til at vi har ulike <emphasis>scope</emphasis>, er for å kunne handtere kompleksitet. Ved hjelp av
<emphasis>scope</emphasis> kan vi avgrense hvor en variabel er synling.</para>
</formalpara>
<simpara>Vi har tre ulike typer <emphasis>scope</emphasis>:</simpara>
<itemizedlist>
<listitem>
<simpara>En variabel definert innenfor klammeparanteser, er i et <emphasis>scope</emphasis> definert av klammeparantesene.</simpara>
</listitem>
<listitem>
<simpara>En variabel som er definert utenfor et hvert sett av klammeparanteser, er i et globalt <emphasis>scope</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>En variabel som er definert med kommandoen <emphasis>static</emphasis> forann seg, befinner seg
i <emphasis>scopet</emphasis> til kompileringsenheten<footnote><simpara>kompileringsenhet; kodefila pluss headerfiler</simpara></footnote></simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="_analyse">
<title>Analyse</title>
<simpara>Før vi begynner å programmere, må vi ha en god forståelse av hva vi egentlig skal få til.
Hvilket problem skal vi egentlig løse? Vi må med andre ord analysere oppgaven.</simpara>
<formalpara>
<title>Læringsmål</title>
<para>
<screen> - å analysere et problem</screen>
</para>
</formalpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="bilder/analyse.jpg" contentwidth="200"/>
</imageobject>
<textobject><phrase>300</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Hva betyr det egentlig å analysere? Analyse og syntese er to motpareter. Når du analyserer
betrakter du noe som er satt sammen av mange deler. Under analysen kommer du
frem til mindre delproblemer, og hvordan disse står i forhold til hverandre. Disse
mindre delproblemene kan du så analysere videre igjen.
På den måten analyserer du deg frem til en forståelse av hvordan noe er satt sammen og
fungerer.</simpara>
<simpara>Motsatsen til <emphasis>analyse</emphasis> heter <emphasis>syntese</emphasis>. Her har vi har kunnskap om to ulike deler,
som vi setter sammen til kunnskap om èn ny del.</simpara>
<simpara>Når vi utfører en objektorientert analyse er vi interessert i å finne de ulike
relevante objektene, og deres egenskaper. Ta for eksempel en objektorienter analyse
av en bil. Hva er de viktigste delen, og egenskapene til disse delene? Jo, det kan
være slik som at en bil har dører. Dørene må kunne åpnes og lukkes. I tillegg har
dørene vindu. De må kunne åpnes og lukkes. Ei dør har en lås. Den må kunne låses
opp og igjen. En lås har en nøkkel. Denne har en radiosender som kan kommunisere
med låsen. Denne radiosenderen må ha en id eller digital nøkkel, slik at
radiokommunikasjonen er sikker. Om vi tar for oss motoren, så skjønner du at vi
kan skrive side opp og side ned om alle objektene vi finner, og relevante egenskaper
til disse ulike objektene. Da skjønner du også at litt av kunsten rundt
analyse-arbeidet er å treffe rett med hensyn til graden av detaljer.</simpara>
<simpara>Eller sagt på en litt annen måte; det å være på rett abstraksjonsnivå i forhold
til det problemet man ønsker å løse, eller finne ut av, er veldig viktig. Er man
på et for lavt abstraksjonsnivå får man ikke noe nytte av analysen, siden det bare
blir en sky av detaljer. Er man derimot på et for høyt abstraksjonsnivå, klarer man
ikke å gå inn i problemstilligen og komme opp med en modell eller forståelse, som tar
deg videre i problemløsningsprosessen.</simpara>
<simpara>Uansett, analyse går ut på å avdekke de relevante delene og
egenskapene til disse, samt hvordan de ulike objektene samhandler med hverandre
for å løse en oppgave. Denne måten å tenke på fungere rimelig bra for mange
problemer som vi ønsker å løse ved hjelp av en datamaskin. Men, du skal vite at
dette er ikke den eneste måte å gå frem på, det finnes en rekke andre metoder.
Og igjen, husk på at objekt analyse er bare atter et triks for å handtere kompleksitet.
Vi bruker analyse for å bygge kunnskap og forståelse rundt det
problemet vi ønsker å løse.</simpara>
<simpara>Men, nå ble det mye abstrakt snakk her. For å forstå dette stoffet, må vi konkretisere det
med et eller flere eksempler. Det første eksempelet vi skal ta for oss, er et
dataprogram som skal hjelpe oss å avvikle et skirenn. Dette er ei ganske stor
og <emphasis>rund</emphasis> progblemstilling, så her trengs det litt analyse for å komme videre.
Når vi har analysret litt, skal vi strukturere og programmere. Og til slutt har vi
kanskje et verktøy som kan hjelp oss i å avvikle et skirenn.</simpara>
<simpara>(Det andre og siste eksempelet vi skal se på, er utviklingen av et Space-Invader-lignende
spill, med grafikk og lydeffekter. )</simpara>
</chapter>
<chapter xml:id="_ski_data_et_eksempel">
<title>Ski-data, et eksempel</title>
<simpara>Dette kapittelet skal ta for seg analyse, design og implementasjon av et
dataprogram som skal hjelp oss med å avvikle et skirenn.</simpara>
</chapter>
<chapter xml:id="_spaceinvader_et_eksempel">
<title>Spaceinvader, et eksempel</title>
<simpara>todo: alt &#8230;&#8203;</simpara>
</chapter>
<bibliography xml:id="_bibliografi">
<title>Bibliografi</title>
<bibliodiv>
<title>Bøker</title>
<bibliomixed>
<bibliomisc><anchor xml:id="taoup" xreflabel="[taoup]"/>[taoup] Eric Steven Raymond. 'The Art of Unix Programming'. Addison-Wesley. ISBN 0-13-142901-9.</bibliomisc>
</bibliomixed>
<bibliomixed>
<bibliomisc><anchor xml:id="walsh-muellner" xreflabel="[walsh-muellner]"/>[walsh-muellner] Norman Walsh &amp; Leonard Muellner. 'DocBook - The Definitive Guide'. O’Reilly &amp; Associates. 1999. ISBN 1-56592-580-7.</bibliomisc>
</bibliomixed>
</bibliodiv>
</bibliography>
</book>